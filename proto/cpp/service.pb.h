// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#ifndef PROTOBUF_INCLUDED_service_2eproto
#define PROTOBUF_INCLUDED_service_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "contract.pb.h"
#include "marketdata.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_service_2eproto 

namespace protobuf_service_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_service_2eproto
namespace pb {
class GreekRequest;
class GreekRequestDefaultTypeInternal;
extern GreekRequestDefaultTypeInternal _GreekRequest_default_instance_;
class GreekResponse;
class GreekResponseDefaultTypeInternal;
extern GreekResponseDefaultTypeInternal _GreekResponse_default_instance_;
class GreekResponse_Greek;
class GreekResponse_GreekDefaultTypeInternal;
extern GreekResponse_GreekDefaultTypeInternal _GreekResponse_Greek_default_instance_;
class ImpliedVolRequest;
class ImpliedVolRequestDefaultTypeInternal;
extern ImpliedVolRequestDefaultTypeInternal _ImpliedVolRequest_default_instance_;
class ImpliedVolResponse;
class ImpliedVolResponseDefaultTypeInternal;
extern ImpliedVolResponseDefaultTypeInternal _ImpliedVolResponse_default_instance_;
class PriceRequest;
class PriceRequestDefaultTypeInternal;
extern PriceRequestDefaultTypeInternal _PriceRequest_default_instance_;
class PriceResponse;
class PriceResponseDefaultTypeInternal;
extern PriceResponseDefaultTypeInternal _PriceResponse_default_instance_;
}  // namespace pb
namespace google {
namespace protobuf {
template<> ::pb::GreekRequest* Arena::CreateMaybeMessage<::pb::GreekRequest>(Arena*);
template<> ::pb::GreekResponse* Arena::CreateMaybeMessage<::pb::GreekResponse>(Arena*);
template<> ::pb::GreekResponse_Greek* Arena::CreateMaybeMessage<::pb::GreekResponse_Greek>(Arena*);
template<> ::pb::ImpliedVolRequest* Arena::CreateMaybeMessage<::pb::ImpliedVolRequest>(Arena*);
template<> ::pb::ImpliedVolResponse* Arena::CreateMaybeMessage<::pb::ImpliedVolResponse>(Arena*);
template<> ::pb::PriceRequest* Arena::CreateMaybeMessage<::pb::PriceRequest>(Arena*);
template<> ::pb::PriceResponse* Arena::CreateMaybeMessage<::pb::PriceResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace pb {

// ===================================================================

class PriceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.PriceRequest) */ {
 public:
  PriceRequest();
  virtual ~PriceRequest();

  PriceRequest(const PriceRequest& from);

  inline PriceRequest& operator=(const PriceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PriceRequest(PriceRequest&& from) noexcept
    : PriceRequest() {
    *this = ::std::move(from);
  }

  inline PriceRequest& operator=(PriceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PriceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PriceRequest* internal_default_instance() {
    return reinterpret_cast<const PriceRequest*>(
               &_PriceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PriceRequest* other);
  friend void swap(PriceRequest& a, PriceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PriceRequest* New() const final {
    return CreateMaybeMessage<PriceRequest>(NULL);
  }

  PriceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PriceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PriceRequest& from);
  void MergeFrom(const PriceRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pb.European contract = 2;
  bool has_contract() const;
  void clear_contract();
  static const int kContractFieldNumber = 2;
  private:
  const ::pb::European& _internal_contract() const;
  public:
  const ::pb::European& contract() const;
  ::pb::European* release_contract();
  ::pb::European* mutable_contract();
  void set_allocated_contract(::pb::European* contract);

  // .pb.OptionMarket marketdata = 3;
  bool has_marketdata() const;
  void clear_marketdata();
  static const int kMarketdataFieldNumber = 3;
  private:
  const ::pb::OptionMarket& _internal_marketdata() const;
  public:
  const ::pb::OptionMarket& marketdata() const;
  ::pb::OptionMarket* release_marketdata();
  ::pb::OptionMarket* mutable_marketdata();
  void set_allocated_marketdata(::pb::OptionMarket* marketdata);

  // double pricingdate = 1;
  void clear_pricingdate();
  static const int kPricingdateFieldNumber = 1;
  double pricingdate() const;
  void set_pricingdate(double value);

  // @@protoc_insertion_point(class_scope:pb.PriceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pb::European* contract_;
  ::pb::OptionMarket* marketdata_;
  double pricingdate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PriceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.PriceResponse) */ {
 public:
  PriceResponse();
  virtual ~PriceResponse();

  PriceResponse(const PriceResponse& from);

  inline PriceResponse& operator=(const PriceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PriceResponse(PriceResponse&& from) noexcept
    : PriceResponse() {
    *this = ::std::move(from);
  }

  inline PriceResponse& operator=(PriceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PriceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PriceResponse* internal_default_instance() {
    return reinterpret_cast<const PriceResponse*>(
               &_PriceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PriceResponse* other);
  friend void swap(PriceResponse& a, PriceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PriceResponse* New() const final {
    return CreateMaybeMessage<PriceResponse>(NULL);
  }

  PriceResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PriceResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PriceResponse& from);
  void MergeFrom(const PriceResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 3;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // double price = 2;
  void clear_price();
  static const int kPriceFieldNumber = 2;
  double price() const;
  void set_price(double value);

  // @@protoc_insertion_point(class_scope:pb.PriceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  double price_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GreekRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.GreekRequest) */ {
 public:
  GreekRequest();
  virtual ~GreekRequest();

  GreekRequest(const GreekRequest& from);

  inline GreekRequest& operator=(const GreekRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GreekRequest(GreekRequest&& from) noexcept
    : GreekRequest() {
    *this = ::std::move(from);
  }

  inline GreekRequest& operator=(GreekRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GreekRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GreekRequest* internal_default_instance() {
    return reinterpret_cast<const GreekRequest*>(
               &_GreekRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GreekRequest* other);
  friend void swap(GreekRequest& a, GreekRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GreekRequest* New() const final {
    return CreateMaybeMessage<GreekRequest>(NULL);
  }

  GreekRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GreekRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GreekRequest& from);
  void MergeFrom(const GreekRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GreekRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string greek = 2;
  int greek_size() const;
  void clear_greek();
  static const int kGreekFieldNumber = 2;
  const ::std::string& greek(int index) const;
  ::std::string* mutable_greek(int index);
  void set_greek(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_greek(int index, ::std::string&& value);
  #endif
  void set_greek(int index, const char* value);
  void set_greek(int index, const char* value, size_t size);
  ::std::string* add_greek();
  void add_greek(const ::std::string& value);
  #if LANG_CXX11
  void add_greek(::std::string&& value);
  #endif
  void add_greek(const char* value);
  void add_greek(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& greek() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_greek();

  // .pb.PriceRequest request = 1;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 1;
  private:
  const ::pb::PriceRequest& _internal_request() const;
  public:
  const ::pb::PriceRequest& request() const;
  ::pb::PriceRequest* release_request();
  ::pb::PriceRequest* mutable_request();
  void set_allocated_request(::pb::PriceRequest* request);

  // @@protoc_insertion_point(class_scope:pb.GreekRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> greek_;
  ::pb::PriceRequest* request_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GreekResponse_Greek : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.GreekResponse.Greek) */ {
 public:
  GreekResponse_Greek();
  virtual ~GreekResponse_Greek();

  GreekResponse_Greek(const GreekResponse_Greek& from);

  inline GreekResponse_Greek& operator=(const GreekResponse_Greek& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GreekResponse_Greek(GreekResponse_Greek&& from) noexcept
    : GreekResponse_Greek() {
    *this = ::std::move(from);
  }

  inline GreekResponse_Greek& operator=(GreekResponse_Greek&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GreekResponse_Greek& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GreekResponse_Greek* internal_default_instance() {
    return reinterpret_cast<const GreekResponse_Greek*>(
               &_GreekResponse_Greek_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GreekResponse_Greek* other);
  friend void swap(GreekResponse_Greek& a, GreekResponse_Greek& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GreekResponse_Greek* New() const final {
    return CreateMaybeMessage<GreekResponse_Greek>(NULL);
  }

  GreekResponse_Greek* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GreekResponse_Greek>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GreekResponse_Greek& from);
  void MergeFrom(const GreekResponse_Greek& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GreekResponse_Greek* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string label = 1;
  void clear_label();
  static const int kLabelFieldNumber = 1;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // string error = 3;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // double value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:pb.GreekResponse.Greek)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  double value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GreekResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.GreekResponse) */ {
 public:
  GreekResponse();
  virtual ~GreekResponse();

  GreekResponse(const GreekResponse& from);

  inline GreekResponse& operator=(const GreekResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GreekResponse(GreekResponse&& from) noexcept
    : GreekResponse() {
    *this = ::std::move(from);
  }

  inline GreekResponse& operator=(GreekResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GreekResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GreekResponse* internal_default_instance() {
    return reinterpret_cast<const GreekResponse*>(
               &_GreekResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GreekResponse* other);
  friend void swap(GreekResponse& a, GreekResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GreekResponse* New() const final {
    return CreateMaybeMessage<GreekResponse>(NULL);
  }

  GreekResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GreekResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GreekResponse& from);
  void MergeFrom(const GreekResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GreekResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GreekResponse_Greek Greek;

  // accessors -------------------------------------------------------

  // repeated .pb.GreekResponse.Greek greeks = 1;
  int greeks_size() const;
  void clear_greeks();
  static const int kGreeksFieldNumber = 1;
  ::pb::GreekResponse_Greek* mutable_greeks(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::GreekResponse_Greek >*
      mutable_greeks();
  const ::pb::GreekResponse_Greek& greeks(int index) const;
  ::pb::GreekResponse_Greek* add_greeks();
  const ::google::protobuf::RepeatedPtrField< ::pb::GreekResponse_Greek >&
      greeks() const;

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:pb.GreekResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::GreekResponse_Greek > greeks_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImpliedVolRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.ImpliedVolRequest) */ {
 public:
  ImpliedVolRequest();
  virtual ~ImpliedVolRequest();

  ImpliedVolRequest(const ImpliedVolRequest& from);

  inline ImpliedVolRequest& operator=(const ImpliedVolRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImpliedVolRequest(ImpliedVolRequest&& from) noexcept
    : ImpliedVolRequest() {
    *this = ::std::move(from);
  }

  inline ImpliedVolRequest& operator=(ImpliedVolRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImpliedVolRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImpliedVolRequest* internal_default_instance() {
    return reinterpret_cast<const ImpliedVolRequest*>(
               &_ImpliedVolRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ImpliedVolRequest* other);
  friend void swap(ImpliedVolRequest& a, ImpliedVolRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImpliedVolRequest* New() const final {
    return CreateMaybeMessage<ImpliedVolRequest>(NULL);
  }

  ImpliedVolRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImpliedVolRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImpliedVolRequest& from);
  void MergeFrom(const ImpliedVolRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImpliedVolRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.OptionQuoteSlice quotes = 3;
  int quotes_size() const;
  void clear_quotes();
  static const int kQuotesFieldNumber = 3;
  ::pb::OptionQuoteSlice* mutable_quotes(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::OptionQuoteSlice >*
      mutable_quotes();
  const ::pb::OptionQuoteSlice& quotes(int index) const;
  ::pb::OptionQuoteSlice* add_quotes();
  const ::google::protobuf::RepeatedPtrField< ::pb::OptionQuoteSlice >&
      quotes() const;

  // .pb.OptionMarket marketdata = 2;
  bool has_marketdata() const;
  void clear_marketdata();
  static const int kMarketdataFieldNumber = 2;
  private:
  const ::pb::OptionMarket& _internal_marketdata() const;
  public:
  const ::pb::OptionMarket& marketdata() const;
  ::pb::OptionMarket* release_marketdata();
  ::pb::OptionMarket* mutable_marketdata();
  void set_allocated_marketdata(::pb::OptionMarket* marketdata);

  // double pricingdate = 1;
  void clear_pricingdate();
  static const int kPricingdateFieldNumber = 1;
  double pricingdate() const;
  void set_pricingdate(double value);

  // @@protoc_insertion_point(class_scope:pb.ImpliedVolRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::OptionQuoteSlice > quotes_;
  ::pb::OptionMarket* marketdata_;
  double pricingdate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImpliedVolResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.ImpliedVolResponse) */ {
 public:
  ImpliedVolResponse();
  virtual ~ImpliedVolResponse();

  ImpliedVolResponse(const ImpliedVolResponse& from);

  inline ImpliedVolResponse& operator=(const ImpliedVolResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImpliedVolResponse(ImpliedVolResponse&& from) noexcept
    : ImpliedVolResponse() {
    *this = ::std::move(from);
  }

  inline ImpliedVolResponse& operator=(ImpliedVolResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImpliedVolResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImpliedVolResponse* internal_default_instance() {
    return reinterpret_cast<const ImpliedVolResponse*>(
               &_ImpliedVolResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ImpliedVolResponse* other);
  friend void swap(ImpliedVolResponse& a, ImpliedVolResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImpliedVolResponse* New() const final {
    return CreateMaybeMessage<ImpliedVolResponse>(NULL);
  }

  ImpliedVolResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImpliedVolResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImpliedVolResponse& from);
  void MergeFrom(const ImpliedVolResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImpliedVolResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .pb.ImpliedVolSurface volsurface = 1;
  bool has_volsurface() const;
  void clear_volsurface();
  static const int kVolsurfaceFieldNumber = 1;
  private:
  const ::pb::ImpliedVolSurface& _internal_volsurface() const;
  public:
  const ::pb::ImpliedVolSurface& volsurface() const;
  ::pb::ImpliedVolSurface* release_volsurface();
  ::pb::ImpliedVolSurface* mutable_volsurface();
  void set_allocated_volsurface(::pb::ImpliedVolSurface* volsurface);

  // @@protoc_insertion_point(class_scope:pb.ImpliedVolResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::pb::ImpliedVolSurface* volsurface_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PriceRequest

// double pricingdate = 1;
inline void PriceRequest::clear_pricingdate() {
  pricingdate_ = 0;
}
inline double PriceRequest::pricingdate() const {
  // @@protoc_insertion_point(field_get:pb.PriceRequest.pricingdate)
  return pricingdate_;
}
inline void PriceRequest::set_pricingdate(double value) {
  
  pricingdate_ = value;
  // @@protoc_insertion_point(field_set:pb.PriceRequest.pricingdate)
}

// .pb.European contract = 2;
inline bool PriceRequest::has_contract() const {
  return this != internal_default_instance() && contract_ != NULL;
}
inline const ::pb::European& PriceRequest::_internal_contract() const {
  return *contract_;
}
inline const ::pb::European& PriceRequest::contract() const {
  const ::pb::European* p = contract_;
  // @@protoc_insertion_point(field_get:pb.PriceRequest.contract)
  return p != NULL ? *p : *reinterpret_cast<const ::pb::European*>(
      &::pb::_European_default_instance_);
}
inline ::pb::European* PriceRequest::release_contract() {
  // @@protoc_insertion_point(field_release:pb.PriceRequest.contract)
  
  ::pb::European* temp = contract_;
  contract_ = NULL;
  return temp;
}
inline ::pb::European* PriceRequest::mutable_contract() {
  
  if (contract_ == NULL) {
    auto* p = CreateMaybeMessage<::pb::European>(GetArenaNoVirtual());
    contract_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.PriceRequest.contract)
  return contract_;
}
inline void PriceRequest::set_allocated_contract(::pb::European* contract) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(contract_);
  }
  if (contract) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      contract = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, contract, submessage_arena);
    }
    
  } else {
    
  }
  contract_ = contract;
  // @@protoc_insertion_point(field_set_allocated:pb.PriceRequest.contract)
}

// .pb.OptionMarket marketdata = 3;
inline bool PriceRequest::has_marketdata() const {
  return this != internal_default_instance() && marketdata_ != NULL;
}
inline const ::pb::OptionMarket& PriceRequest::_internal_marketdata() const {
  return *marketdata_;
}
inline const ::pb::OptionMarket& PriceRequest::marketdata() const {
  const ::pb::OptionMarket* p = marketdata_;
  // @@protoc_insertion_point(field_get:pb.PriceRequest.marketdata)
  return p != NULL ? *p : *reinterpret_cast<const ::pb::OptionMarket*>(
      &::pb::_OptionMarket_default_instance_);
}
inline ::pb::OptionMarket* PriceRequest::release_marketdata() {
  // @@protoc_insertion_point(field_release:pb.PriceRequest.marketdata)
  
  ::pb::OptionMarket* temp = marketdata_;
  marketdata_ = NULL;
  return temp;
}
inline ::pb::OptionMarket* PriceRequest::mutable_marketdata() {
  
  if (marketdata_ == NULL) {
    auto* p = CreateMaybeMessage<::pb::OptionMarket>(GetArenaNoVirtual());
    marketdata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.PriceRequest.marketdata)
  return marketdata_;
}
inline void PriceRequest::set_allocated_marketdata(::pb::OptionMarket* marketdata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(marketdata_);
  }
  if (marketdata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      marketdata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, marketdata, submessage_arena);
    }
    
  } else {
    
  }
  marketdata_ = marketdata;
  // @@protoc_insertion_point(field_set_allocated:pb.PriceRequest.marketdata)
}

// -------------------------------------------------------------------

// PriceResponse

// double price = 2;
inline void PriceResponse::clear_price() {
  price_ = 0;
}
inline double PriceResponse::price() const {
  // @@protoc_insertion_point(field_get:pb.PriceResponse.price)
  return price_;
}
inline void PriceResponse::set_price(double value) {
  
  price_ = value;
  // @@protoc_insertion_point(field_set:pb.PriceResponse.price)
}

// string error = 3;
inline void PriceResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PriceResponse::error() const {
  // @@protoc_insertion_point(field_get:pb.PriceResponse.error)
  return error_.GetNoArena();
}
inline void PriceResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.PriceResponse.error)
}
#if LANG_CXX11
inline void PriceResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.PriceResponse.error)
}
#endif
inline void PriceResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.PriceResponse.error)
}
inline void PriceResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.PriceResponse.error)
}
inline ::std::string* PriceResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:pb.PriceResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PriceResponse::release_error() {
  // @@protoc_insertion_point(field_release:pb.PriceResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PriceResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:pb.PriceResponse.error)
}

// -------------------------------------------------------------------

// GreekRequest

// .pb.PriceRequest request = 1;
inline bool GreekRequest::has_request() const {
  return this != internal_default_instance() && request_ != NULL;
}
inline void GreekRequest::clear_request() {
  if (GetArenaNoVirtual() == NULL && request_ != NULL) {
    delete request_;
  }
  request_ = NULL;
}
inline const ::pb::PriceRequest& GreekRequest::_internal_request() const {
  return *request_;
}
inline const ::pb::PriceRequest& GreekRequest::request() const {
  const ::pb::PriceRequest* p = request_;
  // @@protoc_insertion_point(field_get:pb.GreekRequest.request)
  return p != NULL ? *p : *reinterpret_cast<const ::pb::PriceRequest*>(
      &::pb::_PriceRequest_default_instance_);
}
inline ::pb::PriceRequest* GreekRequest::release_request() {
  // @@protoc_insertion_point(field_release:pb.GreekRequest.request)
  
  ::pb::PriceRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline ::pb::PriceRequest* GreekRequest::mutable_request() {
  
  if (request_ == NULL) {
    auto* p = CreateMaybeMessage<::pb::PriceRequest>(GetArenaNoVirtual());
    request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.GreekRequest.request)
  return request_;
}
inline void GreekRequest::set_allocated_request(::pb::PriceRequest* request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete request_;
  }
  if (request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:pb.GreekRequest.request)
}

// repeated string greek = 2;
inline int GreekRequest::greek_size() const {
  return greek_.size();
}
inline void GreekRequest::clear_greek() {
  greek_.Clear();
}
inline const ::std::string& GreekRequest::greek(int index) const {
  // @@protoc_insertion_point(field_get:pb.GreekRequest.greek)
  return greek_.Get(index);
}
inline ::std::string* GreekRequest::mutable_greek(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GreekRequest.greek)
  return greek_.Mutable(index);
}
inline void GreekRequest::set_greek(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.GreekRequest.greek)
  greek_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GreekRequest::set_greek(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:pb.GreekRequest.greek)
  greek_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GreekRequest::set_greek(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  greek_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.GreekRequest.greek)
}
inline void GreekRequest::set_greek(int index, const char* value, size_t size) {
  greek_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.GreekRequest.greek)
}
inline ::std::string* GreekRequest::add_greek() {
  // @@protoc_insertion_point(field_add_mutable:pb.GreekRequest.greek)
  return greek_.Add();
}
inline void GreekRequest::add_greek(const ::std::string& value) {
  greek_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.GreekRequest.greek)
}
#if LANG_CXX11
inline void GreekRequest::add_greek(::std::string&& value) {
  greek_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.GreekRequest.greek)
}
#endif
inline void GreekRequest::add_greek(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  greek_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.GreekRequest.greek)
}
inline void GreekRequest::add_greek(const char* value, size_t size) {
  greek_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.GreekRequest.greek)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GreekRequest::greek() const {
  // @@protoc_insertion_point(field_list:pb.GreekRequest.greek)
  return greek_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GreekRequest::mutable_greek() {
  // @@protoc_insertion_point(field_mutable_list:pb.GreekRequest.greek)
  return &greek_;
}

// -------------------------------------------------------------------

// GreekResponse_Greek

// string label = 1;
inline void GreekResponse_Greek::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GreekResponse_Greek::label() const {
  // @@protoc_insertion_point(field_get:pb.GreekResponse.Greek.label)
  return label_.GetNoArena();
}
inline void GreekResponse_Greek::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.GreekResponse.Greek.label)
}
#if LANG_CXX11
inline void GreekResponse_Greek::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.GreekResponse.Greek.label)
}
#endif
inline void GreekResponse_Greek::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.GreekResponse.Greek.label)
}
inline void GreekResponse_Greek::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.GreekResponse.Greek.label)
}
inline ::std::string* GreekResponse_Greek::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:pb.GreekResponse.Greek.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GreekResponse_Greek::release_label() {
  // @@protoc_insertion_point(field_release:pb.GreekResponse.Greek.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GreekResponse_Greek::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:pb.GreekResponse.Greek.label)
}

// double value = 2;
inline void GreekResponse_Greek::clear_value() {
  value_ = 0;
}
inline double GreekResponse_Greek::value() const {
  // @@protoc_insertion_point(field_get:pb.GreekResponse.Greek.value)
  return value_;
}
inline void GreekResponse_Greek::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:pb.GreekResponse.Greek.value)
}

// string error = 3;
inline void GreekResponse_Greek::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GreekResponse_Greek::error() const {
  // @@protoc_insertion_point(field_get:pb.GreekResponse.Greek.error)
  return error_.GetNoArena();
}
inline void GreekResponse_Greek::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.GreekResponse.Greek.error)
}
#if LANG_CXX11
inline void GreekResponse_Greek::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.GreekResponse.Greek.error)
}
#endif
inline void GreekResponse_Greek::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.GreekResponse.Greek.error)
}
inline void GreekResponse_Greek::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.GreekResponse.Greek.error)
}
inline ::std::string* GreekResponse_Greek::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:pb.GreekResponse.Greek.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GreekResponse_Greek::release_error() {
  // @@protoc_insertion_point(field_release:pb.GreekResponse.Greek.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GreekResponse_Greek::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:pb.GreekResponse.Greek.error)
}

// -------------------------------------------------------------------

// GreekResponse

// repeated .pb.GreekResponse.Greek greeks = 1;
inline int GreekResponse::greeks_size() const {
  return greeks_.size();
}
inline void GreekResponse::clear_greeks() {
  greeks_.Clear();
}
inline ::pb::GreekResponse_Greek* GreekResponse::mutable_greeks(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GreekResponse.greeks)
  return greeks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::GreekResponse_Greek >*
GreekResponse::mutable_greeks() {
  // @@protoc_insertion_point(field_mutable_list:pb.GreekResponse.greeks)
  return &greeks_;
}
inline const ::pb::GreekResponse_Greek& GreekResponse::greeks(int index) const {
  // @@protoc_insertion_point(field_get:pb.GreekResponse.greeks)
  return greeks_.Get(index);
}
inline ::pb::GreekResponse_Greek* GreekResponse::add_greeks() {
  // @@protoc_insertion_point(field_add:pb.GreekResponse.greeks)
  return greeks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::GreekResponse_Greek >&
GreekResponse::greeks() const {
  // @@protoc_insertion_point(field_list:pb.GreekResponse.greeks)
  return greeks_;
}

// string error = 2;
inline void GreekResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GreekResponse::error() const {
  // @@protoc_insertion_point(field_get:pb.GreekResponse.error)
  return error_.GetNoArena();
}
inline void GreekResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.GreekResponse.error)
}
#if LANG_CXX11
inline void GreekResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.GreekResponse.error)
}
#endif
inline void GreekResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.GreekResponse.error)
}
inline void GreekResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.GreekResponse.error)
}
inline ::std::string* GreekResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:pb.GreekResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GreekResponse::release_error() {
  // @@protoc_insertion_point(field_release:pb.GreekResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GreekResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:pb.GreekResponse.error)
}

// -------------------------------------------------------------------

// ImpliedVolRequest

// double pricingdate = 1;
inline void ImpliedVolRequest::clear_pricingdate() {
  pricingdate_ = 0;
}
inline double ImpliedVolRequest::pricingdate() const {
  // @@protoc_insertion_point(field_get:pb.ImpliedVolRequest.pricingdate)
  return pricingdate_;
}
inline void ImpliedVolRequest::set_pricingdate(double value) {
  
  pricingdate_ = value;
  // @@protoc_insertion_point(field_set:pb.ImpliedVolRequest.pricingdate)
}

// .pb.OptionMarket marketdata = 2;
inline bool ImpliedVolRequest::has_marketdata() const {
  return this != internal_default_instance() && marketdata_ != NULL;
}
inline const ::pb::OptionMarket& ImpliedVolRequest::_internal_marketdata() const {
  return *marketdata_;
}
inline const ::pb::OptionMarket& ImpliedVolRequest::marketdata() const {
  const ::pb::OptionMarket* p = marketdata_;
  // @@protoc_insertion_point(field_get:pb.ImpliedVolRequest.marketdata)
  return p != NULL ? *p : *reinterpret_cast<const ::pb::OptionMarket*>(
      &::pb::_OptionMarket_default_instance_);
}
inline ::pb::OptionMarket* ImpliedVolRequest::release_marketdata() {
  // @@protoc_insertion_point(field_release:pb.ImpliedVolRequest.marketdata)
  
  ::pb::OptionMarket* temp = marketdata_;
  marketdata_ = NULL;
  return temp;
}
inline ::pb::OptionMarket* ImpliedVolRequest::mutable_marketdata() {
  
  if (marketdata_ == NULL) {
    auto* p = CreateMaybeMessage<::pb::OptionMarket>(GetArenaNoVirtual());
    marketdata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.ImpliedVolRequest.marketdata)
  return marketdata_;
}
inline void ImpliedVolRequest::set_allocated_marketdata(::pb::OptionMarket* marketdata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(marketdata_);
  }
  if (marketdata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      marketdata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, marketdata, submessage_arena);
    }
    
  } else {
    
  }
  marketdata_ = marketdata;
  // @@protoc_insertion_point(field_set_allocated:pb.ImpliedVolRequest.marketdata)
}

// repeated .pb.OptionQuoteSlice quotes = 3;
inline int ImpliedVolRequest::quotes_size() const {
  return quotes_.size();
}
inline ::pb::OptionQuoteSlice* ImpliedVolRequest::mutable_quotes(int index) {
  // @@protoc_insertion_point(field_mutable:pb.ImpliedVolRequest.quotes)
  return quotes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::OptionQuoteSlice >*
ImpliedVolRequest::mutable_quotes() {
  // @@protoc_insertion_point(field_mutable_list:pb.ImpliedVolRequest.quotes)
  return &quotes_;
}
inline const ::pb::OptionQuoteSlice& ImpliedVolRequest::quotes(int index) const {
  // @@protoc_insertion_point(field_get:pb.ImpliedVolRequest.quotes)
  return quotes_.Get(index);
}
inline ::pb::OptionQuoteSlice* ImpliedVolRequest::add_quotes() {
  // @@protoc_insertion_point(field_add:pb.ImpliedVolRequest.quotes)
  return quotes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::OptionQuoteSlice >&
ImpliedVolRequest::quotes() const {
  // @@protoc_insertion_point(field_list:pb.ImpliedVolRequest.quotes)
  return quotes_;
}

// -------------------------------------------------------------------

// ImpliedVolResponse

// .pb.ImpliedVolSurface volsurface = 1;
inline bool ImpliedVolResponse::has_volsurface() const {
  return this != internal_default_instance() && volsurface_ != NULL;
}
inline const ::pb::ImpliedVolSurface& ImpliedVolResponse::_internal_volsurface() const {
  return *volsurface_;
}
inline const ::pb::ImpliedVolSurface& ImpliedVolResponse::volsurface() const {
  const ::pb::ImpliedVolSurface* p = volsurface_;
  // @@protoc_insertion_point(field_get:pb.ImpliedVolResponse.volsurface)
  return p != NULL ? *p : *reinterpret_cast<const ::pb::ImpliedVolSurface*>(
      &::pb::_ImpliedVolSurface_default_instance_);
}
inline ::pb::ImpliedVolSurface* ImpliedVolResponse::release_volsurface() {
  // @@protoc_insertion_point(field_release:pb.ImpliedVolResponse.volsurface)
  
  ::pb::ImpliedVolSurface* temp = volsurface_;
  volsurface_ = NULL;
  return temp;
}
inline ::pb::ImpliedVolSurface* ImpliedVolResponse::mutable_volsurface() {
  
  if (volsurface_ == NULL) {
    auto* p = CreateMaybeMessage<::pb::ImpliedVolSurface>(GetArenaNoVirtual());
    volsurface_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.ImpliedVolResponse.volsurface)
  return volsurface_;
}
inline void ImpliedVolResponse::set_allocated_volsurface(::pb::ImpliedVolSurface* volsurface) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(volsurface_);
  }
  if (volsurface) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      volsurface = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, volsurface, submessage_arena);
    }
    
  } else {
    
  }
  volsurface_ = volsurface;
  // @@protoc_insertion_point(field_set_allocated:pb.ImpliedVolResponse.volsurface)
}

// string error = 2;
inline void ImpliedVolResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImpliedVolResponse::error() const {
  // @@protoc_insertion_point(field_get:pb.ImpliedVolResponse.error)
  return error_.GetNoArena();
}
inline void ImpliedVolResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.ImpliedVolResponse.error)
}
#if LANG_CXX11
inline void ImpliedVolResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.ImpliedVolResponse.error)
}
#endif
inline void ImpliedVolResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.ImpliedVolResponse.error)
}
inline void ImpliedVolResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.ImpliedVolResponse.error)
}
inline ::std::string* ImpliedVolResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:pb.ImpliedVolResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImpliedVolResponse::release_error() {
  // @@protoc_insertion_point(field_release:pb.ImpliedVolResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImpliedVolResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:pb.ImpliedVolResponse.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_service_2eproto
