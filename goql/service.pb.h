// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#ifndef PROTOBUF_INCLUDED_service_2eproto
#define PROTOBUF_INCLUDED_service_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_service_2eproto 

namespace protobuf_service_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[18];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_service_2eproto
namespace gooption {
class European;
class EuropeanDefaultTypeInternal;
extern EuropeanDefaultTypeInternal _European_default_instance_;
class FlatVol;
class FlatVolDefaultTypeInternal;
extern FlatVolDefaultTypeInternal _FlatVol_default_instance_;
class GreekRequest;
class GreekRequestDefaultTypeInternal;
extern GreekRequestDefaultTypeInternal _GreekRequest_default_instance_;
class GreekResponse;
class GreekResponseDefaultTypeInternal;
extern GreekResponseDefaultTypeInternal _GreekResponse_default_instance_;
class GreekResponse_Greek;
class GreekResponse_GreekDefaultTypeInternal;
extern GreekResponse_GreekDefaultTypeInternal _GreekResponse_Greek_default_instance_;
class ImpliedVolQuote;
class ImpliedVolQuoteDefaultTypeInternal;
extern ImpliedVolQuoteDefaultTypeInternal _ImpliedVolQuote_default_instance_;
class ImpliedVolRequest;
class ImpliedVolRequestDefaultTypeInternal;
extern ImpliedVolRequestDefaultTypeInternal _ImpliedVolRequest_default_instance_;
class ImpliedVolResponse;
class ImpliedVolResponseDefaultTypeInternal;
extern ImpliedVolResponseDefaultTypeInternal _ImpliedVolResponse_default_instance_;
class ImpliedVolSlice;
class ImpliedVolSliceDefaultTypeInternal;
extern ImpliedVolSliceDefaultTypeInternal _ImpliedVolSlice_default_instance_;
class ImpliedVolSurface;
class ImpliedVolSurfaceDefaultTypeInternal;
extern ImpliedVolSurfaceDefaultTypeInternal _ImpliedVolSurface_default_instance_;
class Index;
class IndexDefaultTypeInternal;
extern IndexDefaultTypeInternal _Index_default_instance_;
class OptionMarket;
class OptionMarketDefaultTypeInternal;
extern OptionMarketDefaultTypeInternal _OptionMarket_default_instance_;
class OptionQuote;
class OptionQuoteDefaultTypeInternal;
extern OptionQuoteDefaultTypeInternal _OptionQuote_default_instance_;
class OptionQuoteSlice;
class OptionQuoteSliceDefaultTypeInternal;
extern OptionQuoteSliceDefaultTypeInternal _OptionQuoteSlice_default_instance_;
class PriceRequest;
class PriceRequestDefaultTypeInternal;
extern PriceRequestDefaultTypeInternal _PriceRequest_default_instance_;
class PriceResponse;
class PriceResponseDefaultTypeInternal;
extern PriceResponseDefaultTypeInternal _PriceResponse_default_instance_;
class RiskFreeRate;
class RiskFreeRateDefaultTypeInternal;
extern RiskFreeRateDefaultTypeInternal _RiskFreeRate_default_instance_;
class Spot;
class SpotDefaultTypeInternal;
extern SpotDefaultTypeInternal _Spot_default_instance_;
}  // namespace gooption
namespace google {
namespace protobuf {
template<> ::gooption::European* Arena::CreateMaybeMessage<::gooption::European>(Arena*);
template<> ::gooption::FlatVol* Arena::CreateMaybeMessage<::gooption::FlatVol>(Arena*);
template<> ::gooption::GreekRequest* Arena::CreateMaybeMessage<::gooption::GreekRequest>(Arena*);
template<> ::gooption::GreekResponse* Arena::CreateMaybeMessage<::gooption::GreekResponse>(Arena*);
template<> ::gooption::GreekResponse_Greek* Arena::CreateMaybeMessage<::gooption::GreekResponse_Greek>(Arena*);
template<> ::gooption::ImpliedVolQuote* Arena::CreateMaybeMessage<::gooption::ImpliedVolQuote>(Arena*);
template<> ::gooption::ImpliedVolRequest* Arena::CreateMaybeMessage<::gooption::ImpliedVolRequest>(Arena*);
template<> ::gooption::ImpliedVolResponse* Arena::CreateMaybeMessage<::gooption::ImpliedVolResponse>(Arena*);
template<> ::gooption::ImpliedVolSlice* Arena::CreateMaybeMessage<::gooption::ImpliedVolSlice>(Arena*);
template<> ::gooption::ImpliedVolSurface* Arena::CreateMaybeMessage<::gooption::ImpliedVolSurface>(Arena*);
template<> ::gooption::Index* Arena::CreateMaybeMessage<::gooption::Index>(Arena*);
template<> ::gooption::OptionMarket* Arena::CreateMaybeMessage<::gooption::OptionMarket>(Arena*);
template<> ::gooption::OptionQuote* Arena::CreateMaybeMessage<::gooption::OptionQuote>(Arena*);
template<> ::gooption::OptionQuoteSlice* Arena::CreateMaybeMessage<::gooption::OptionQuoteSlice>(Arena*);
template<> ::gooption::PriceRequest* Arena::CreateMaybeMessage<::gooption::PriceRequest>(Arena*);
template<> ::gooption::PriceResponse* Arena::CreateMaybeMessage<::gooption::PriceResponse>(Arena*);
template<> ::gooption::RiskFreeRate* Arena::CreateMaybeMessage<::gooption::RiskFreeRate>(Arena*);
template<> ::gooption::Spot* Arena::CreateMaybeMessage<::gooption::Spot>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace gooption {

// ===================================================================

class European : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.European) */ {
 public:
  European();
  virtual ~European();

  European(const European& from);

  inline European& operator=(const European& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  European(European&& from) noexcept
    : European() {
    *this = ::std::move(from);
  }

  inline European& operator=(European&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const European& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const European* internal_default_instance() {
    return reinterpret_cast<const European*>(
               &_European_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(European* other);
  friend void swap(European& a, European& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline European* New() const final {
    return CreateMaybeMessage<European>(NULL);
  }

  European* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<European>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const European& from);
  void MergeFrom(const European& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(European* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ticker = 2;
  void clear_ticker();
  static const int kTickerFieldNumber = 2;
  const ::std::string& ticker() const;
  void set_ticker(const ::std::string& value);
  #if LANG_CXX11
  void set_ticker(::std::string&& value);
  #endif
  void set_ticker(const char* value);
  void set_ticker(const char* value, size_t size);
  ::std::string* mutable_ticker();
  ::std::string* release_ticker();
  void set_allocated_ticker(::std::string* ticker);

  // string undticker = 3;
  void clear_undticker();
  static const int kUndtickerFieldNumber = 3;
  const ::std::string& undticker() const;
  void set_undticker(const ::std::string& value);
  #if LANG_CXX11
  void set_undticker(::std::string&& value);
  #endif
  void set_undticker(const char* value);
  void set_undticker(const char* value, size_t size);
  ::std::string* mutable_undticker();
  ::std::string* release_undticker();
  void set_allocated_undticker(::std::string* undticker);

  // string putcall = 6;
  void clear_putcall();
  static const int kPutcallFieldNumber = 6;
  const ::std::string& putcall() const;
  void set_putcall(const ::std::string& value);
  #if LANG_CXX11
  void set_putcall(::std::string&& value);
  #endif
  void set_putcall(const char* value);
  void set_putcall(const char* value, size_t size);
  ::std::string* mutable_putcall();
  ::std::string* release_putcall();
  void set_allocated_putcall(::std::string* putcall);

  // double timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // double strike = 4;
  void clear_strike();
  static const int kStrikeFieldNumber = 4;
  double strike() const;
  void set_strike(double value);

  // double expiry = 5;
  void clear_expiry();
  static const int kExpiryFieldNumber = 5;
  double expiry() const;
  void set_expiry(double value);

  // @@protoc_insertion_point(class_scope:gooption.European)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ticker_;
  ::google::protobuf::internal::ArenaStringPtr undticker_;
  ::google::protobuf::internal::ArenaStringPtr putcall_;
  double timestamp_;
  double strike_;
  double expiry_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Index : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.Index) */ {
 public:
  Index();
  virtual ~Index();

  Index(const Index& from);

  inline Index& operator=(const Index& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Index(Index&& from) noexcept
    : Index() {
    *this = ::std::move(from);
  }

  inline Index& operator=(Index&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Index& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Index* internal_default_instance() {
    return reinterpret_cast<const Index*>(
               &_Index_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Index* other);
  friend void swap(Index& a, Index& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Index* New() const final {
    return CreateMaybeMessage<Index>(NULL);
  }

  Index* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Index>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Index& from);
  void MergeFrom(const Index& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Index* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ticker = 2;
  void clear_ticker();
  static const int kTickerFieldNumber = 2;
  const ::std::string& ticker() const;
  void set_ticker(const ::std::string& value);
  #if LANG_CXX11
  void set_ticker(::std::string&& value);
  #endif
  void set_ticker(const char* value);
  void set_ticker(const char* value, size_t size);
  ::std::string* mutable_ticker();
  ::std::string* release_ticker();
  void set_allocated_ticker(::std::string* ticker);

  // double timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // double value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:gooption.Index)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ticker_;
  double timestamp_;
  double value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Spot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.Spot) */ {
 public:
  Spot();
  virtual ~Spot();

  Spot(const Spot& from);

  inline Spot& operator=(const Spot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Spot(Spot&& from) noexcept
    : Spot() {
    *this = ::std::move(from);
  }

  inline Spot& operator=(Spot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Spot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Spot* internal_default_instance() {
    return reinterpret_cast<const Spot*>(
               &_Spot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Spot* other);
  friend void swap(Spot& a, Spot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Spot* New() const final {
    return CreateMaybeMessage<Spot>(NULL);
  }

  Spot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Spot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Spot& from);
  void MergeFrom(const Spot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Spot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .gooption.Index index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  private:
  const ::gooption::Index& _internal_index() const;
  public:
  const ::gooption::Index& index() const;
  ::gooption::Index* release_index();
  ::gooption::Index* mutable_index();
  void set_allocated_index(::gooption::Index* index);

  // @@protoc_insertion_point(class_scope:gooption.Spot)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::gooption::Index* index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RiskFreeRate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.RiskFreeRate) */ {
 public:
  RiskFreeRate();
  virtual ~RiskFreeRate();

  RiskFreeRate(const RiskFreeRate& from);

  inline RiskFreeRate& operator=(const RiskFreeRate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RiskFreeRate(RiskFreeRate&& from) noexcept
    : RiskFreeRate() {
    *this = ::std::move(from);
  }

  inline RiskFreeRate& operator=(RiskFreeRate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RiskFreeRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RiskFreeRate* internal_default_instance() {
    return reinterpret_cast<const RiskFreeRate*>(
               &_RiskFreeRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RiskFreeRate* other);
  friend void swap(RiskFreeRate& a, RiskFreeRate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RiskFreeRate* New() const final {
    return CreateMaybeMessage<RiskFreeRate>(NULL);
  }

  RiskFreeRate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RiskFreeRate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RiskFreeRate& from);
  void MergeFrom(const RiskFreeRate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RiskFreeRate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .gooption.Index index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  private:
  const ::gooption::Index& _internal_index() const;
  public:
  const ::gooption::Index& index() const;
  ::gooption::Index* release_index();
  ::gooption::Index* mutable_index();
  void set_allocated_index(::gooption::Index* index);

  // @@protoc_insertion_point(class_scope:gooption.RiskFreeRate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::gooption::Index* index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlatVol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.FlatVol) */ {
 public:
  FlatVol();
  virtual ~FlatVol();

  FlatVol(const FlatVol& from);

  inline FlatVol& operator=(const FlatVol& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlatVol(FlatVol&& from) noexcept
    : FlatVol() {
    *this = ::std::move(from);
  }

  inline FlatVol& operator=(FlatVol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlatVol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlatVol* internal_default_instance() {
    return reinterpret_cast<const FlatVol*>(
               &_FlatVol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(FlatVol* other);
  friend void swap(FlatVol& a, FlatVol& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlatVol* New() const final {
    return CreateMaybeMessage<FlatVol>(NULL);
  }

  FlatVol* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlatVol>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlatVol& from);
  void MergeFrom(const FlatVol& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlatVol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .gooption.Index index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  private:
  const ::gooption::Index& _internal_index() const;
  public:
  const ::gooption::Index& index() const;
  ::gooption::Index* release_index();
  ::gooption::Index* mutable_index();
  void set_allocated_index(::gooption::Index* index);

  // @@protoc_insertion_point(class_scope:gooption.FlatVol)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::gooption::Index* index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OptionQuote : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.OptionQuote) */ {
 public:
  OptionQuote();
  virtual ~OptionQuote();

  OptionQuote(const OptionQuote& from);

  inline OptionQuote& operator=(const OptionQuote& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OptionQuote(OptionQuote&& from) noexcept
    : OptionQuote() {
    *this = ::std::move(from);
  }

  inline OptionQuote& operator=(OptionQuote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OptionQuote& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OptionQuote* internal_default_instance() {
    return reinterpret_cast<const OptionQuote*>(
               &_OptionQuote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(OptionQuote* other);
  friend void swap(OptionQuote& a, OptionQuote& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OptionQuote* New() const final {
    return CreateMaybeMessage<OptionQuote>(NULL);
  }

  OptionQuote* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OptionQuote>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OptionQuote& from);
  void MergeFrom(const OptionQuote& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptionQuote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string putcall = 13;
  void clear_putcall();
  static const int kPutcallFieldNumber = 13;
  const ::std::string& putcall() const;
  void set_putcall(const ::std::string& value);
  #if LANG_CXX11
  void set_putcall(::std::string&& value);
  #endif
  void set_putcall(const char* value);
  void set_putcall(const char* value, size_t size);
  ::std::string* mutable_putcall();
  ::std::string* release_putcall();
  void set_allocated_putcall(::std::string* putcall);

  // double timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // double strike = 8;
  void clear_strike();
  static const int kStrikeFieldNumber = 8;
  double strike() const;
  void set_strike(double value);

  // double bid = 9;
  void clear_bid();
  static const int kBidFieldNumber = 9;
  double bid() const;
  void set_bid(double value);

  // double ask = 10;
  void clear_ask();
  static const int kAskFieldNumber = 10;
  double ask() const;
  void set_ask(double value);

  // double volume = 11;
  void clear_volume();
  static const int kVolumeFieldNumber = 11;
  double volume() const;
  void set_volume(double value);

  // double openinterest = 12;
  void clear_openinterest();
  static const int kOpeninterestFieldNumber = 12;
  double openinterest() const;
  void set_openinterest(double value);

  // @@protoc_insertion_point(class_scope:gooption.OptionQuote)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr putcall_;
  double timestamp_;
  double strike_;
  double bid_;
  double ask_;
  double volume_;
  double openinterest_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OptionQuoteSlice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.OptionQuoteSlice) */ {
 public:
  OptionQuoteSlice();
  virtual ~OptionQuoteSlice();

  OptionQuoteSlice(const OptionQuoteSlice& from);

  inline OptionQuoteSlice& operator=(const OptionQuoteSlice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OptionQuoteSlice(OptionQuoteSlice&& from) noexcept
    : OptionQuoteSlice() {
    *this = ::std::move(from);
  }

  inline OptionQuoteSlice& operator=(OptionQuoteSlice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OptionQuoteSlice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OptionQuoteSlice* internal_default_instance() {
    return reinterpret_cast<const OptionQuoteSlice*>(
               &_OptionQuoteSlice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(OptionQuoteSlice* other);
  friend void swap(OptionQuoteSlice& a, OptionQuoteSlice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OptionQuoteSlice* New() const final {
    return CreateMaybeMessage<OptionQuoteSlice>(NULL);
  }

  OptionQuoteSlice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OptionQuoteSlice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OptionQuoteSlice& from);
  void MergeFrom(const OptionQuoteSlice& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptionQuoteSlice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gooption.OptionQuote puts = 3;
  int puts_size() const;
  void clear_puts();
  static const int kPutsFieldNumber = 3;
  ::gooption::OptionQuote* mutable_puts(int index);
  ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuote >*
      mutable_puts();
  const ::gooption::OptionQuote& puts(int index) const;
  ::gooption::OptionQuote* add_puts();
  const ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuote >&
      puts() const;

  // repeated .gooption.OptionQuote calls = 4;
  int calls_size() const;
  void clear_calls();
  static const int kCallsFieldNumber = 4;
  ::gooption::OptionQuote* mutable_calls(int index);
  ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuote >*
      mutable_calls();
  const ::gooption::OptionQuote& calls(int index) const;
  ::gooption::OptionQuote* add_calls();
  const ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuote >&
      calls() const;

  // double timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // double expiry = 2;
  void clear_expiry();
  static const int kExpiryFieldNumber = 2;
  double expiry() const;
  void set_expiry(double value);

  // @@protoc_insertion_point(class_scope:gooption.OptionQuoteSlice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuote > puts_;
  ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuote > calls_;
  double timestamp_;
  double expiry_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OptionMarket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.OptionMarket) */ {
 public:
  OptionMarket();
  virtual ~OptionMarket();

  OptionMarket(const OptionMarket& from);

  inline OptionMarket& operator=(const OptionMarket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OptionMarket(OptionMarket&& from) noexcept
    : OptionMarket() {
    *this = ::std::move(from);
  }

  inline OptionMarket& operator=(OptionMarket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OptionMarket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OptionMarket* internal_default_instance() {
    return reinterpret_cast<const OptionMarket*>(
               &_OptionMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(OptionMarket* other);
  friend void swap(OptionMarket& a, OptionMarket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OptionMarket* New() const final {
    return CreateMaybeMessage<OptionMarket>(NULL);
  }

  OptionMarket* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OptionMarket>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OptionMarket& from);
  void MergeFrom(const OptionMarket& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptionMarket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .gooption.Spot spot = 2;
  bool has_spot() const;
  void clear_spot();
  static const int kSpotFieldNumber = 2;
  private:
  const ::gooption::Spot& _internal_spot() const;
  public:
  const ::gooption::Spot& spot() const;
  ::gooption::Spot* release_spot();
  ::gooption::Spot* mutable_spot();
  void set_allocated_spot(::gooption::Spot* spot);

  // .gooption.FlatVol vol = 3;
  bool has_vol() const;
  void clear_vol();
  static const int kVolFieldNumber = 3;
  private:
  const ::gooption::FlatVol& _internal_vol() const;
  public:
  const ::gooption::FlatVol& vol() const;
  ::gooption::FlatVol* release_vol();
  ::gooption::FlatVol* mutable_vol();
  void set_allocated_vol(::gooption::FlatVol* vol);

  // .gooption.RiskFreeRate rate = 4;
  bool has_rate() const;
  void clear_rate();
  static const int kRateFieldNumber = 4;
  private:
  const ::gooption::RiskFreeRate& _internal_rate() const;
  public:
  const ::gooption::RiskFreeRate& rate() const;
  ::gooption::RiskFreeRate* release_rate();
  ::gooption::RiskFreeRate* mutable_rate();
  void set_allocated_rate(::gooption::RiskFreeRate* rate);

  // double timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:gooption.OptionMarket)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::gooption::Spot* spot_;
  ::gooption::FlatVol* vol_;
  ::gooption::RiskFreeRate* rate_;
  double timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImpliedVolQuote : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.ImpliedVolQuote) */ {
 public:
  ImpliedVolQuote();
  virtual ~ImpliedVolQuote();

  ImpliedVolQuote(const ImpliedVolQuote& from);

  inline ImpliedVolQuote& operator=(const ImpliedVolQuote& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImpliedVolQuote(ImpliedVolQuote&& from) noexcept
    : ImpliedVolQuote() {
    *this = ::std::move(from);
  }

  inline ImpliedVolQuote& operator=(ImpliedVolQuote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImpliedVolQuote& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImpliedVolQuote* internal_default_instance() {
    return reinterpret_cast<const ImpliedVolQuote*>(
               &_ImpliedVolQuote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ImpliedVolQuote* other);
  friend void swap(ImpliedVolQuote& a, ImpliedVolQuote& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImpliedVolQuote* New() const final {
    return CreateMaybeMessage<ImpliedVolQuote>(NULL);
  }

  ImpliedVolQuote* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImpliedVolQuote>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImpliedVolQuote& from);
  void MergeFrom(const ImpliedVolQuote& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImpliedVolQuote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 3;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .gooption.OptionQuote input = 2;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 2;
  private:
  const ::gooption::OptionQuote& _internal_input() const;
  public:
  const ::gooption::OptionQuote& input() const;
  ::gooption::OptionQuote* release_input();
  ::gooption::OptionQuote* mutable_input();
  void set_allocated_input(::gooption::OptionQuote* input);

  // double timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // double vol = 4;
  void clear_vol();
  static const int kVolFieldNumber = 4;
  double vol() const;
  void set_vol(double value);

  // int64 nbiteration = 5;
  void clear_nbiteration();
  static const int kNbiterationFieldNumber = 5;
  ::google::protobuf::int64 nbiteration() const;
  void set_nbiteration(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:gooption.ImpliedVolQuote)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::gooption::OptionQuote* input_;
  double timestamp_;
  double vol_;
  ::google::protobuf::int64 nbiteration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImpliedVolSlice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.ImpliedVolSlice) */ {
 public:
  ImpliedVolSlice();
  virtual ~ImpliedVolSlice();

  ImpliedVolSlice(const ImpliedVolSlice& from);

  inline ImpliedVolSlice& operator=(const ImpliedVolSlice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImpliedVolSlice(ImpliedVolSlice&& from) noexcept
    : ImpliedVolSlice() {
    *this = ::std::move(from);
  }

  inline ImpliedVolSlice& operator=(ImpliedVolSlice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImpliedVolSlice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImpliedVolSlice* internal_default_instance() {
    return reinterpret_cast<const ImpliedVolSlice*>(
               &_ImpliedVolSlice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ImpliedVolSlice* other);
  friend void swap(ImpliedVolSlice& a, ImpliedVolSlice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImpliedVolSlice* New() const final {
    return CreateMaybeMessage<ImpliedVolSlice>(NULL);
  }

  ImpliedVolSlice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImpliedVolSlice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImpliedVolSlice& from);
  void MergeFrom(const ImpliedVolSlice& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImpliedVolSlice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gooption.ImpliedVolQuote quotes = 4;
  int quotes_size() const;
  void clear_quotes();
  static const int kQuotesFieldNumber = 4;
  ::gooption::ImpliedVolQuote* mutable_quotes(int index);
  ::google::protobuf::RepeatedPtrField< ::gooption::ImpliedVolQuote >*
      mutable_quotes();
  const ::gooption::ImpliedVolQuote& quotes(int index) const;
  ::gooption::ImpliedVolQuote* add_quotes();
  const ::google::protobuf::RepeatedPtrField< ::gooption::ImpliedVolQuote >&
      quotes() const;

  // double timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // double expiry = 3;
  void clear_expiry();
  static const int kExpiryFieldNumber = 3;
  double expiry() const;
  void set_expiry(double value);

  // bool iserror = 2;
  void clear_iserror();
  static const int kIserrorFieldNumber = 2;
  bool iserror() const;
  void set_iserror(bool value);

  // @@protoc_insertion_point(class_scope:gooption.ImpliedVolSlice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::gooption::ImpliedVolQuote > quotes_;
  double timestamp_;
  double expiry_;
  bool iserror_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImpliedVolSurface : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.ImpliedVolSurface) */ {
 public:
  ImpliedVolSurface();
  virtual ~ImpliedVolSurface();

  ImpliedVolSurface(const ImpliedVolSurface& from);

  inline ImpliedVolSurface& operator=(const ImpliedVolSurface& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImpliedVolSurface(ImpliedVolSurface&& from) noexcept
    : ImpliedVolSurface() {
    *this = ::std::move(from);
  }

  inline ImpliedVolSurface& operator=(ImpliedVolSurface&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImpliedVolSurface& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImpliedVolSurface* internal_default_instance() {
    return reinterpret_cast<const ImpliedVolSurface*>(
               &_ImpliedVolSurface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ImpliedVolSurface* other);
  friend void swap(ImpliedVolSurface& a, ImpliedVolSurface& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImpliedVolSurface* New() const final {
    return CreateMaybeMessage<ImpliedVolSurface>(NULL);
  }

  ImpliedVolSurface* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImpliedVolSurface>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImpliedVolSurface& from);
  void MergeFrom(const ImpliedVolSurface& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImpliedVolSurface* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gooption.ImpliedVolSlice slices = 2;
  int slices_size() const;
  void clear_slices();
  static const int kSlicesFieldNumber = 2;
  ::gooption::ImpliedVolSlice* mutable_slices(int index);
  ::google::protobuf::RepeatedPtrField< ::gooption::ImpliedVolSlice >*
      mutable_slices();
  const ::gooption::ImpliedVolSlice& slices(int index) const;
  ::gooption::ImpliedVolSlice* add_slices();
  const ::google::protobuf::RepeatedPtrField< ::gooption::ImpliedVolSlice >&
      slices() const;

  // double timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:gooption.ImpliedVolSurface)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::gooption::ImpliedVolSlice > slices_;
  double timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PriceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.PriceRequest) */ {
 public:
  PriceRequest();
  virtual ~PriceRequest();

  PriceRequest(const PriceRequest& from);

  inline PriceRequest& operator=(const PriceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PriceRequest(PriceRequest&& from) noexcept
    : PriceRequest() {
    *this = ::std::move(from);
  }

  inline PriceRequest& operator=(PriceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PriceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PriceRequest* internal_default_instance() {
    return reinterpret_cast<const PriceRequest*>(
               &_PriceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(PriceRequest* other);
  friend void swap(PriceRequest& a, PriceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PriceRequest* New() const final {
    return CreateMaybeMessage<PriceRequest>(NULL);
  }

  PriceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PriceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PriceRequest& from);
  void MergeFrom(const PriceRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .gooption.European contract = 2;
  bool has_contract() const;
  void clear_contract();
  static const int kContractFieldNumber = 2;
  private:
  const ::gooption::European& _internal_contract() const;
  public:
  const ::gooption::European& contract() const;
  ::gooption::European* release_contract();
  ::gooption::European* mutable_contract();
  void set_allocated_contract(::gooption::European* contract);

  // .gooption.OptionMarket marketdata = 3;
  bool has_marketdata() const;
  void clear_marketdata();
  static const int kMarketdataFieldNumber = 3;
  private:
  const ::gooption::OptionMarket& _internal_marketdata() const;
  public:
  const ::gooption::OptionMarket& marketdata() const;
  ::gooption::OptionMarket* release_marketdata();
  ::gooption::OptionMarket* mutable_marketdata();
  void set_allocated_marketdata(::gooption::OptionMarket* marketdata);

  // double pricingdate = 1;
  void clear_pricingdate();
  static const int kPricingdateFieldNumber = 1;
  double pricingdate() const;
  void set_pricingdate(double value);

  // @@protoc_insertion_point(class_scope:gooption.PriceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::gooption::European* contract_;
  ::gooption::OptionMarket* marketdata_;
  double pricingdate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PriceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.PriceResponse) */ {
 public:
  PriceResponse();
  virtual ~PriceResponse();

  PriceResponse(const PriceResponse& from);

  inline PriceResponse& operator=(const PriceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PriceResponse(PriceResponse&& from) noexcept
    : PriceResponse() {
    *this = ::std::move(from);
  }

  inline PriceResponse& operator=(PriceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PriceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PriceResponse* internal_default_instance() {
    return reinterpret_cast<const PriceResponse*>(
               &_PriceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(PriceResponse* other);
  friend void swap(PriceResponse& a, PriceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PriceResponse* New() const final {
    return CreateMaybeMessage<PriceResponse>(NULL);
  }

  PriceResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PriceResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PriceResponse& from);
  void MergeFrom(const PriceResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 3;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // double price = 2;
  void clear_price();
  static const int kPriceFieldNumber = 2;
  double price() const;
  void set_price(double value);

  // @@protoc_insertion_point(class_scope:gooption.PriceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  double price_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GreekRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.GreekRequest) */ {
 public:
  GreekRequest();
  virtual ~GreekRequest();

  GreekRequest(const GreekRequest& from);

  inline GreekRequest& operator=(const GreekRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GreekRequest(GreekRequest&& from) noexcept
    : GreekRequest() {
    *this = ::std::move(from);
  }

  inline GreekRequest& operator=(GreekRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GreekRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GreekRequest* internal_default_instance() {
    return reinterpret_cast<const GreekRequest*>(
               &_GreekRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(GreekRequest* other);
  friend void swap(GreekRequest& a, GreekRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GreekRequest* New() const final {
    return CreateMaybeMessage<GreekRequest>(NULL);
  }

  GreekRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GreekRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GreekRequest& from);
  void MergeFrom(const GreekRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GreekRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string greek = 2;
  int greek_size() const;
  void clear_greek();
  static const int kGreekFieldNumber = 2;
  const ::std::string& greek(int index) const;
  ::std::string* mutable_greek(int index);
  void set_greek(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_greek(int index, ::std::string&& value);
  #endif
  void set_greek(int index, const char* value);
  void set_greek(int index, const char* value, size_t size);
  ::std::string* add_greek();
  void add_greek(const ::std::string& value);
  #if LANG_CXX11
  void add_greek(::std::string&& value);
  #endif
  void add_greek(const char* value);
  void add_greek(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& greek() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_greek();

  // .gooption.PriceRequest request = 1;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 1;
  private:
  const ::gooption::PriceRequest& _internal_request() const;
  public:
  const ::gooption::PriceRequest& request() const;
  ::gooption::PriceRequest* release_request();
  ::gooption::PriceRequest* mutable_request();
  void set_allocated_request(::gooption::PriceRequest* request);

  // @@protoc_insertion_point(class_scope:gooption.GreekRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> greek_;
  ::gooption::PriceRequest* request_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GreekResponse_Greek : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.GreekResponse.Greek) */ {
 public:
  GreekResponse_Greek();
  virtual ~GreekResponse_Greek();

  GreekResponse_Greek(const GreekResponse_Greek& from);

  inline GreekResponse_Greek& operator=(const GreekResponse_Greek& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GreekResponse_Greek(GreekResponse_Greek&& from) noexcept
    : GreekResponse_Greek() {
    *this = ::std::move(from);
  }

  inline GreekResponse_Greek& operator=(GreekResponse_Greek&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GreekResponse_Greek& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GreekResponse_Greek* internal_default_instance() {
    return reinterpret_cast<const GreekResponse_Greek*>(
               &_GreekResponse_Greek_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(GreekResponse_Greek* other);
  friend void swap(GreekResponse_Greek& a, GreekResponse_Greek& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GreekResponse_Greek* New() const final {
    return CreateMaybeMessage<GreekResponse_Greek>(NULL);
  }

  GreekResponse_Greek* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GreekResponse_Greek>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GreekResponse_Greek& from);
  void MergeFrom(const GreekResponse_Greek& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GreekResponse_Greek* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string label = 1;
  void clear_label();
  static const int kLabelFieldNumber = 1;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // string error = 3;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // double value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:gooption.GreekResponse.Greek)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  double value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GreekResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.GreekResponse) */ {
 public:
  GreekResponse();
  virtual ~GreekResponse();

  GreekResponse(const GreekResponse& from);

  inline GreekResponse& operator=(const GreekResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GreekResponse(GreekResponse&& from) noexcept
    : GreekResponse() {
    *this = ::std::move(from);
  }

  inline GreekResponse& operator=(GreekResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GreekResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GreekResponse* internal_default_instance() {
    return reinterpret_cast<const GreekResponse*>(
               &_GreekResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(GreekResponse* other);
  friend void swap(GreekResponse& a, GreekResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GreekResponse* New() const final {
    return CreateMaybeMessage<GreekResponse>(NULL);
  }

  GreekResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GreekResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GreekResponse& from);
  void MergeFrom(const GreekResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GreekResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GreekResponse_Greek Greek;

  // accessors -------------------------------------------------------

  // repeated .gooption.GreekResponse.Greek greeks = 1;
  int greeks_size() const;
  void clear_greeks();
  static const int kGreeksFieldNumber = 1;
  ::gooption::GreekResponse_Greek* mutable_greeks(int index);
  ::google::protobuf::RepeatedPtrField< ::gooption::GreekResponse_Greek >*
      mutable_greeks();
  const ::gooption::GreekResponse_Greek& greeks(int index) const;
  ::gooption::GreekResponse_Greek* add_greeks();
  const ::google::protobuf::RepeatedPtrField< ::gooption::GreekResponse_Greek >&
      greeks() const;

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:gooption.GreekResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::gooption::GreekResponse_Greek > greeks_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImpliedVolRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.ImpliedVolRequest) */ {
 public:
  ImpliedVolRequest();
  virtual ~ImpliedVolRequest();

  ImpliedVolRequest(const ImpliedVolRequest& from);

  inline ImpliedVolRequest& operator=(const ImpliedVolRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImpliedVolRequest(ImpliedVolRequest&& from) noexcept
    : ImpliedVolRequest() {
    *this = ::std::move(from);
  }

  inline ImpliedVolRequest& operator=(ImpliedVolRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImpliedVolRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImpliedVolRequest* internal_default_instance() {
    return reinterpret_cast<const ImpliedVolRequest*>(
               &_ImpliedVolRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ImpliedVolRequest* other);
  friend void swap(ImpliedVolRequest& a, ImpliedVolRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImpliedVolRequest* New() const final {
    return CreateMaybeMessage<ImpliedVolRequest>(NULL);
  }

  ImpliedVolRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImpliedVolRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImpliedVolRequest& from);
  void MergeFrom(const ImpliedVolRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImpliedVolRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gooption.OptionQuoteSlice quotes = 3;
  int quotes_size() const;
  void clear_quotes();
  static const int kQuotesFieldNumber = 3;
  ::gooption::OptionQuoteSlice* mutable_quotes(int index);
  ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuoteSlice >*
      mutable_quotes();
  const ::gooption::OptionQuoteSlice& quotes(int index) const;
  ::gooption::OptionQuoteSlice* add_quotes();
  const ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuoteSlice >&
      quotes() const;

  // .gooption.OptionMarket marketdata = 2;
  bool has_marketdata() const;
  void clear_marketdata();
  static const int kMarketdataFieldNumber = 2;
  private:
  const ::gooption::OptionMarket& _internal_marketdata() const;
  public:
  const ::gooption::OptionMarket& marketdata() const;
  ::gooption::OptionMarket* release_marketdata();
  ::gooption::OptionMarket* mutable_marketdata();
  void set_allocated_marketdata(::gooption::OptionMarket* marketdata);

  // double pricingdate = 1;
  void clear_pricingdate();
  static const int kPricingdateFieldNumber = 1;
  double pricingdate() const;
  void set_pricingdate(double value);

  // @@protoc_insertion_point(class_scope:gooption.ImpliedVolRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuoteSlice > quotes_;
  ::gooption::OptionMarket* marketdata_;
  double pricingdate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImpliedVolResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gooption.ImpliedVolResponse) */ {
 public:
  ImpliedVolResponse();
  virtual ~ImpliedVolResponse();

  ImpliedVolResponse(const ImpliedVolResponse& from);

  inline ImpliedVolResponse& operator=(const ImpliedVolResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImpliedVolResponse(ImpliedVolResponse&& from) noexcept
    : ImpliedVolResponse() {
    *this = ::std::move(from);
  }

  inline ImpliedVolResponse& operator=(ImpliedVolResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImpliedVolResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImpliedVolResponse* internal_default_instance() {
    return reinterpret_cast<const ImpliedVolResponse*>(
               &_ImpliedVolResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ImpliedVolResponse* other);
  friend void swap(ImpliedVolResponse& a, ImpliedVolResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImpliedVolResponse* New() const final {
    return CreateMaybeMessage<ImpliedVolResponse>(NULL);
  }

  ImpliedVolResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImpliedVolResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImpliedVolResponse& from);
  void MergeFrom(const ImpliedVolResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImpliedVolResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .gooption.ImpliedVolSurface volsurface = 1;
  bool has_volsurface() const;
  void clear_volsurface();
  static const int kVolsurfaceFieldNumber = 1;
  private:
  const ::gooption::ImpliedVolSurface& _internal_volsurface() const;
  public:
  const ::gooption::ImpliedVolSurface& volsurface() const;
  ::gooption::ImpliedVolSurface* release_volsurface();
  ::gooption::ImpliedVolSurface* mutable_volsurface();
  void set_allocated_volsurface(::gooption::ImpliedVolSurface* volsurface);

  // @@protoc_insertion_point(class_scope:gooption.ImpliedVolResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::gooption::ImpliedVolSurface* volsurface_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// European

// double timestamp = 1;
inline void European::clear_timestamp() {
  timestamp_ = 0;
}
inline double European::timestamp() const {
  // @@protoc_insertion_point(field_get:gooption.European.timestamp)
  return timestamp_;
}
inline void European::set_timestamp(double value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:gooption.European.timestamp)
}

// string ticker = 2;
inline void European::clear_ticker() {
  ticker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& European::ticker() const {
  // @@protoc_insertion_point(field_get:gooption.European.ticker)
  return ticker_.GetNoArena();
}
inline void European::set_ticker(const ::std::string& value) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gooption.European.ticker)
}
#if LANG_CXX11
inline void European::set_ticker(::std::string&& value) {
  
  ticker_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gooption.European.ticker)
}
#endif
inline void European::set_ticker(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gooption.European.ticker)
}
inline void European::set_ticker(const char* value, size_t size) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gooption.European.ticker)
}
inline ::std::string* European::mutable_ticker() {
  
  // @@protoc_insertion_point(field_mutable:gooption.European.ticker)
  return ticker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* European::release_ticker() {
  // @@protoc_insertion_point(field_release:gooption.European.ticker)
  
  return ticker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void European::set_allocated_ticker(::std::string* ticker) {
  if (ticker != NULL) {
    
  } else {
    
  }
  ticker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticker);
  // @@protoc_insertion_point(field_set_allocated:gooption.European.ticker)
}

// string undticker = 3;
inline void European::clear_undticker() {
  undticker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& European::undticker() const {
  // @@protoc_insertion_point(field_get:gooption.European.undticker)
  return undticker_.GetNoArena();
}
inline void European::set_undticker(const ::std::string& value) {
  
  undticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gooption.European.undticker)
}
#if LANG_CXX11
inline void European::set_undticker(::std::string&& value) {
  
  undticker_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gooption.European.undticker)
}
#endif
inline void European::set_undticker(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  undticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gooption.European.undticker)
}
inline void European::set_undticker(const char* value, size_t size) {
  
  undticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gooption.European.undticker)
}
inline ::std::string* European::mutable_undticker() {
  
  // @@protoc_insertion_point(field_mutable:gooption.European.undticker)
  return undticker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* European::release_undticker() {
  // @@protoc_insertion_point(field_release:gooption.European.undticker)
  
  return undticker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void European::set_allocated_undticker(::std::string* undticker) {
  if (undticker != NULL) {
    
  } else {
    
  }
  undticker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), undticker);
  // @@protoc_insertion_point(field_set_allocated:gooption.European.undticker)
}

// double strike = 4;
inline void European::clear_strike() {
  strike_ = 0;
}
inline double European::strike() const {
  // @@protoc_insertion_point(field_get:gooption.European.strike)
  return strike_;
}
inline void European::set_strike(double value) {
  
  strike_ = value;
  // @@protoc_insertion_point(field_set:gooption.European.strike)
}

// double expiry = 5;
inline void European::clear_expiry() {
  expiry_ = 0;
}
inline double European::expiry() const {
  // @@protoc_insertion_point(field_get:gooption.European.expiry)
  return expiry_;
}
inline void European::set_expiry(double value) {
  
  expiry_ = value;
  // @@protoc_insertion_point(field_set:gooption.European.expiry)
}

// string putcall = 6;
inline void European::clear_putcall() {
  putcall_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& European::putcall() const {
  // @@protoc_insertion_point(field_get:gooption.European.putcall)
  return putcall_.GetNoArena();
}
inline void European::set_putcall(const ::std::string& value) {
  
  putcall_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gooption.European.putcall)
}
#if LANG_CXX11
inline void European::set_putcall(::std::string&& value) {
  
  putcall_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gooption.European.putcall)
}
#endif
inline void European::set_putcall(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  putcall_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gooption.European.putcall)
}
inline void European::set_putcall(const char* value, size_t size) {
  
  putcall_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gooption.European.putcall)
}
inline ::std::string* European::mutable_putcall() {
  
  // @@protoc_insertion_point(field_mutable:gooption.European.putcall)
  return putcall_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* European::release_putcall() {
  // @@protoc_insertion_point(field_release:gooption.European.putcall)
  
  return putcall_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void European::set_allocated_putcall(::std::string* putcall) {
  if (putcall != NULL) {
    
  } else {
    
  }
  putcall_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), putcall);
  // @@protoc_insertion_point(field_set_allocated:gooption.European.putcall)
}

// -------------------------------------------------------------------

// Index

// double timestamp = 1;
inline void Index::clear_timestamp() {
  timestamp_ = 0;
}
inline double Index::timestamp() const {
  // @@protoc_insertion_point(field_get:gooption.Index.timestamp)
  return timestamp_;
}
inline void Index::set_timestamp(double value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:gooption.Index.timestamp)
}

// string ticker = 2;
inline void Index::clear_ticker() {
  ticker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Index::ticker() const {
  // @@protoc_insertion_point(field_get:gooption.Index.ticker)
  return ticker_.GetNoArena();
}
inline void Index::set_ticker(const ::std::string& value) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gooption.Index.ticker)
}
#if LANG_CXX11
inline void Index::set_ticker(::std::string&& value) {
  
  ticker_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gooption.Index.ticker)
}
#endif
inline void Index::set_ticker(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gooption.Index.ticker)
}
inline void Index::set_ticker(const char* value, size_t size) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gooption.Index.ticker)
}
inline ::std::string* Index::mutable_ticker() {
  
  // @@protoc_insertion_point(field_mutable:gooption.Index.ticker)
  return ticker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Index::release_ticker() {
  // @@protoc_insertion_point(field_release:gooption.Index.ticker)
  
  return ticker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Index::set_allocated_ticker(::std::string* ticker) {
  if (ticker != NULL) {
    
  } else {
    
  }
  ticker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticker);
  // @@protoc_insertion_point(field_set_allocated:gooption.Index.ticker)
}

// double value = 3;
inline void Index::clear_value() {
  value_ = 0;
}
inline double Index::value() const {
  // @@protoc_insertion_point(field_get:gooption.Index.value)
  return value_;
}
inline void Index::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:gooption.Index.value)
}

// -------------------------------------------------------------------

// Spot

// .gooption.Index index = 1;
inline bool Spot::has_index() const {
  return this != internal_default_instance() && index_ != NULL;
}
inline void Spot::clear_index() {
  if (GetArenaNoVirtual() == NULL && index_ != NULL) {
    delete index_;
  }
  index_ = NULL;
}
inline const ::gooption::Index& Spot::_internal_index() const {
  return *index_;
}
inline const ::gooption::Index& Spot::index() const {
  const ::gooption::Index* p = index_;
  // @@protoc_insertion_point(field_get:gooption.Spot.index)
  return p != NULL ? *p : *reinterpret_cast<const ::gooption::Index*>(
      &::gooption::_Index_default_instance_);
}
inline ::gooption::Index* Spot::release_index() {
  // @@protoc_insertion_point(field_release:gooption.Spot.index)
  
  ::gooption::Index* temp = index_;
  index_ = NULL;
  return temp;
}
inline ::gooption::Index* Spot::mutable_index() {
  
  if (index_ == NULL) {
    auto* p = CreateMaybeMessage<::gooption::Index>(GetArenaNoVirtual());
    index_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gooption.Spot.index)
  return index_;
}
inline void Spot::set_allocated_index(::gooption::Index* index) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete index_;
  }
  if (index) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      index = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, index, submessage_arena);
    }
    
  } else {
    
  }
  index_ = index;
  // @@protoc_insertion_point(field_set_allocated:gooption.Spot.index)
}

// -------------------------------------------------------------------

// RiskFreeRate

// .gooption.Index index = 1;
inline bool RiskFreeRate::has_index() const {
  return this != internal_default_instance() && index_ != NULL;
}
inline void RiskFreeRate::clear_index() {
  if (GetArenaNoVirtual() == NULL && index_ != NULL) {
    delete index_;
  }
  index_ = NULL;
}
inline const ::gooption::Index& RiskFreeRate::_internal_index() const {
  return *index_;
}
inline const ::gooption::Index& RiskFreeRate::index() const {
  const ::gooption::Index* p = index_;
  // @@protoc_insertion_point(field_get:gooption.RiskFreeRate.index)
  return p != NULL ? *p : *reinterpret_cast<const ::gooption::Index*>(
      &::gooption::_Index_default_instance_);
}
inline ::gooption::Index* RiskFreeRate::release_index() {
  // @@protoc_insertion_point(field_release:gooption.RiskFreeRate.index)
  
  ::gooption::Index* temp = index_;
  index_ = NULL;
  return temp;
}
inline ::gooption::Index* RiskFreeRate::mutable_index() {
  
  if (index_ == NULL) {
    auto* p = CreateMaybeMessage<::gooption::Index>(GetArenaNoVirtual());
    index_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gooption.RiskFreeRate.index)
  return index_;
}
inline void RiskFreeRate::set_allocated_index(::gooption::Index* index) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete index_;
  }
  if (index) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      index = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, index, submessage_arena);
    }
    
  } else {
    
  }
  index_ = index;
  // @@protoc_insertion_point(field_set_allocated:gooption.RiskFreeRate.index)
}

// -------------------------------------------------------------------

// FlatVol

// .gooption.Index index = 1;
inline bool FlatVol::has_index() const {
  return this != internal_default_instance() && index_ != NULL;
}
inline void FlatVol::clear_index() {
  if (GetArenaNoVirtual() == NULL && index_ != NULL) {
    delete index_;
  }
  index_ = NULL;
}
inline const ::gooption::Index& FlatVol::_internal_index() const {
  return *index_;
}
inline const ::gooption::Index& FlatVol::index() const {
  const ::gooption::Index* p = index_;
  // @@protoc_insertion_point(field_get:gooption.FlatVol.index)
  return p != NULL ? *p : *reinterpret_cast<const ::gooption::Index*>(
      &::gooption::_Index_default_instance_);
}
inline ::gooption::Index* FlatVol::release_index() {
  // @@protoc_insertion_point(field_release:gooption.FlatVol.index)
  
  ::gooption::Index* temp = index_;
  index_ = NULL;
  return temp;
}
inline ::gooption::Index* FlatVol::mutable_index() {
  
  if (index_ == NULL) {
    auto* p = CreateMaybeMessage<::gooption::Index>(GetArenaNoVirtual());
    index_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gooption.FlatVol.index)
  return index_;
}
inline void FlatVol::set_allocated_index(::gooption::Index* index) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete index_;
  }
  if (index) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      index = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, index, submessage_arena);
    }
    
  } else {
    
  }
  index_ = index;
  // @@protoc_insertion_point(field_set_allocated:gooption.FlatVol.index)
}

// -------------------------------------------------------------------

// OptionQuote

// double timestamp = 1;
inline void OptionQuote::clear_timestamp() {
  timestamp_ = 0;
}
inline double OptionQuote::timestamp() const {
  // @@protoc_insertion_point(field_get:gooption.OptionQuote.timestamp)
  return timestamp_;
}
inline void OptionQuote::set_timestamp(double value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:gooption.OptionQuote.timestamp)
}

// double strike = 8;
inline void OptionQuote::clear_strike() {
  strike_ = 0;
}
inline double OptionQuote::strike() const {
  // @@protoc_insertion_point(field_get:gooption.OptionQuote.strike)
  return strike_;
}
inline void OptionQuote::set_strike(double value) {
  
  strike_ = value;
  // @@protoc_insertion_point(field_set:gooption.OptionQuote.strike)
}

// double bid = 9;
inline void OptionQuote::clear_bid() {
  bid_ = 0;
}
inline double OptionQuote::bid() const {
  // @@protoc_insertion_point(field_get:gooption.OptionQuote.bid)
  return bid_;
}
inline void OptionQuote::set_bid(double value) {
  
  bid_ = value;
  // @@protoc_insertion_point(field_set:gooption.OptionQuote.bid)
}

// double ask = 10;
inline void OptionQuote::clear_ask() {
  ask_ = 0;
}
inline double OptionQuote::ask() const {
  // @@protoc_insertion_point(field_get:gooption.OptionQuote.ask)
  return ask_;
}
inline void OptionQuote::set_ask(double value) {
  
  ask_ = value;
  // @@protoc_insertion_point(field_set:gooption.OptionQuote.ask)
}

// double volume = 11;
inline void OptionQuote::clear_volume() {
  volume_ = 0;
}
inline double OptionQuote::volume() const {
  // @@protoc_insertion_point(field_get:gooption.OptionQuote.volume)
  return volume_;
}
inline void OptionQuote::set_volume(double value) {
  
  volume_ = value;
  // @@protoc_insertion_point(field_set:gooption.OptionQuote.volume)
}

// double openinterest = 12;
inline void OptionQuote::clear_openinterest() {
  openinterest_ = 0;
}
inline double OptionQuote::openinterest() const {
  // @@protoc_insertion_point(field_get:gooption.OptionQuote.openinterest)
  return openinterest_;
}
inline void OptionQuote::set_openinterest(double value) {
  
  openinterest_ = value;
  // @@protoc_insertion_point(field_set:gooption.OptionQuote.openinterest)
}

// string putcall = 13;
inline void OptionQuote::clear_putcall() {
  putcall_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OptionQuote::putcall() const {
  // @@protoc_insertion_point(field_get:gooption.OptionQuote.putcall)
  return putcall_.GetNoArena();
}
inline void OptionQuote::set_putcall(const ::std::string& value) {
  
  putcall_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gooption.OptionQuote.putcall)
}
#if LANG_CXX11
inline void OptionQuote::set_putcall(::std::string&& value) {
  
  putcall_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gooption.OptionQuote.putcall)
}
#endif
inline void OptionQuote::set_putcall(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  putcall_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gooption.OptionQuote.putcall)
}
inline void OptionQuote::set_putcall(const char* value, size_t size) {
  
  putcall_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gooption.OptionQuote.putcall)
}
inline ::std::string* OptionQuote::mutable_putcall() {
  
  // @@protoc_insertion_point(field_mutable:gooption.OptionQuote.putcall)
  return putcall_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OptionQuote::release_putcall() {
  // @@protoc_insertion_point(field_release:gooption.OptionQuote.putcall)
  
  return putcall_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OptionQuote::set_allocated_putcall(::std::string* putcall) {
  if (putcall != NULL) {
    
  } else {
    
  }
  putcall_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), putcall);
  // @@protoc_insertion_point(field_set_allocated:gooption.OptionQuote.putcall)
}

// -------------------------------------------------------------------

// OptionQuoteSlice

// double timestamp = 1;
inline void OptionQuoteSlice::clear_timestamp() {
  timestamp_ = 0;
}
inline double OptionQuoteSlice::timestamp() const {
  // @@protoc_insertion_point(field_get:gooption.OptionQuoteSlice.timestamp)
  return timestamp_;
}
inline void OptionQuoteSlice::set_timestamp(double value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:gooption.OptionQuoteSlice.timestamp)
}

// double expiry = 2;
inline void OptionQuoteSlice::clear_expiry() {
  expiry_ = 0;
}
inline double OptionQuoteSlice::expiry() const {
  // @@protoc_insertion_point(field_get:gooption.OptionQuoteSlice.expiry)
  return expiry_;
}
inline void OptionQuoteSlice::set_expiry(double value) {
  
  expiry_ = value;
  // @@protoc_insertion_point(field_set:gooption.OptionQuoteSlice.expiry)
}

// repeated .gooption.OptionQuote puts = 3;
inline int OptionQuoteSlice::puts_size() const {
  return puts_.size();
}
inline void OptionQuoteSlice::clear_puts() {
  puts_.Clear();
}
inline ::gooption::OptionQuote* OptionQuoteSlice::mutable_puts(int index) {
  // @@protoc_insertion_point(field_mutable:gooption.OptionQuoteSlice.puts)
  return puts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuote >*
OptionQuoteSlice::mutable_puts() {
  // @@protoc_insertion_point(field_mutable_list:gooption.OptionQuoteSlice.puts)
  return &puts_;
}
inline const ::gooption::OptionQuote& OptionQuoteSlice::puts(int index) const {
  // @@protoc_insertion_point(field_get:gooption.OptionQuoteSlice.puts)
  return puts_.Get(index);
}
inline ::gooption::OptionQuote* OptionQuoteSlice::add_puts() {
  // @@protoc_insertion_point(field_add:gooption.OptionQuoteSlice.puts)
  return puts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuote >&
OptionQuoteSlice::puts() const {
  // @@protoc_insertion_point(field_list:gooption.OptionQuoteSlice.puts)
  return puts_;
}

// repeated .gooption.OptionQuote calls = 4;
inline int OptionQuoteSlice::calls_size() const {
  return calls_.size();
}
inline void OptionQuoteSlice::clear_calls() {
  calls_.Clear();
}
inline ::gooption::OptionQuote* OptionQuoteSlice::mutable_calls(int index) {
  // @@protoc_insertion_point(field_mutable:gooption.OptionQuoteSlice.calls)
  return calls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuote >*
OptionQuoteSlice::mutable_calls() {
  // @@protoc_insertion_point(field_mutable_list:gooption.OptionQuoteSlice.calls)
  return &calls_;
}
inline const ::gooption::OptionQuote& OptionQuoteSlice::calls(int index) const {
  // @@protoc_insertion_point(field_get:gooption.OptionQuoteSlice.calls)
  return calls_.Get(index);
}
inline ::gooption::OptionQuote* OptionQuoteSlice::add_calls() {
  // @@protoc_insertion_point(field_add:gooption.OptionQuoteSlice.calls)
  return calls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuote >&
OptionQuoteSlice::calls() const {
  // @@protoc_insertion_point(field_list:gooption.OptionQuoteSlice.calls)
  return calls_;
}

// -------------------------------------------------------------------

// OptionMarket

// double timestamp = 1;
inline void OptionMarket::clear_timestamp() {
  timestamp_ = 0;
}
inline double OptionMarket::timestamp() const {
  // @@protoc_insertion_point(field_get:gooption.OptionMarket.timestamp)
  return timestamp_;
}
inline void OptionMarket::set_timestamp(double value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:gooption.OptionMarket.timestamp)
}

// .gooption.Spot spot = 2;
inline bool OptionMarket::has_spot() const {
  return this != internal_default_instance() && spot_ != NULL;
}
inline void OptionMarket::clear_spot() {
  if (GetArenaNoVirtual() == NULL && spot_ != NULL) {
    delete spot_;
  }
  spot_ = NULL;
}
inline const ::gooption::Spot& OptionMarket::_internal_spot() const {
  return *spot_;
}
inline const ::gooption::Spot& OptionMarket::spot() const {
  const ::gooption::Spot* p = spot_;
  // @@protoc_insertion_point(field_get:gooption.OptionMarket.spot)
  return p != NULL ? *p : *reinterpret_cast<const ::gooption::Spot*>(
      &::gooption::_Spot_default_instance_);
}
inline ::gooption::Spot* OptionMarket::release_spot() {
  // @@protoc_insertion_point(field_release:gooption.OptionMarket.spot)
  
  ::gooption::Spot* temp = spot_;
  spot_ = NULL;
  return temp;
}
inline ::gooption::Spot* OptionMarket::mutable_spot() {
  
  if (spot_ == NULL) {
    auto* p = CreateMaybeMessage<::gooption::Spot>(GetArenaNoVirtual());
    spot_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gooption.OptionMarket.spot)
  return spot_;
}
inline void OptionMarket::set_allocated_spot(::gooption::Spot* spot) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete spot_;
  }
  if (spot) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      spot = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spot, submessage_arena);
    }
    
  } else {
    
  }
  spot_ = spot;
  // @@protoc_insertion_point(field_set_allocated:gooption.OptionMarket.spot)
}

// .gooption.FlatVol vol = 3;
inline bool OptionMarket::has_vol() const {
  return this != internal_default_instance() && vol_ != NULL;
}
inline void OptionMarket::clear_vol() {
  if (GetArenaNoVirtual() == NULL && vol_ != NULL) {
    delete vol_;
  }
  vol_ = NULL;
}
inline const ::gooption::FlatVol& OptionMarket::_internal_vol() const {
  return *vol_;
}
inline const ::gooption::FlatVol& OptionMarket::vol() const {
  const ::gooption::FlatVol* p = vol_;
  // @@protoc_insertion_point(field_get:gooption.OptionMarket.vol)
  return p != NULL ? *p : *reinterpret_cast<const ::gooption::FlatVol*>(
      &::gooption::_FlatVol_default_instance_);
}
inline ::gooption::FlatVol* OptionMarket::release_vol() {
  // @@protoc_insertion_point(field_release:gooption.OptionMarket.vol)
  
  ::gooption::FlatVol* temp = vol_;
  vol_ = NULL;
  return temp;
}
inline ::gooption::FlatVol* OptionMarket::mutable_vol() {
  
  if (vol_ == NULL) {
    auto* p = CreateMaybeMessage<::gooption::FlatVol>(GetArenaNoVirtual());
    vol_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gooption.OptionMarket.vol)
  return vol_;
}
inline void OptionMarket::set_allocated_vol(::gooption::FlatVol* vol) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vol_;
  }
  if (vol) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vol = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vol, submessage_arena);
    }
    
  } else {
    
  }
  vol_ = vol;
  // @@protoc_insertion_point(field_set_allocated:gooption.OptionMarket.vol)
}

// .gooption.RiskFreeRate rate = 4;
inline bool OptionMarket::has_rate() const {
  return this != internal_default_instance() && rate_ != NULL;
}
inline void OptionMarket::clear_rate() {
  if (GetArenaNoVirtual() == NULL && rate_ != NULL) {
    delete rate_;
  }
  rate_ = NULL;
}
inline const ::gooption::RiskFreeRate& OptionMarket::_internal_rate() const {
  return *rate_;
}
inline const ::gooption::RiskFreeRate& OptionMarket::rate() const {
  const ::gooption::RiskFreeRate* p = rate_;
  // @@protoc_insertion_point(field_get:gooption.OptionMarket.rate)
  return p != NULL ? *p : *reinterpret_cast<const ::gooption::RiskFreeRate*>(
      &::gooption::_RiskFreeRate_default_instance_);
}
inline ::gooption::RiskFreeRate* OptionMarket::release_rate() {
  // @@protoc_insertion_point(field_release:gooption.OptionMarket.rate)
  
  ::gooption::RiskFreeRate* temp = rate_;
  rate_ = NULL;
  return temp;
}
inline ::gooption::RiskFreeRate* OptionMarket::mutable_rate() {
  
  if (rate_ == NULL) {
    auto* p = CreateMaybeMessage<::gooption::RiskFreeRate>(GetArenaNoVirtual());
    rate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gooption.OptionMarket.rate)
  return rate_;
}
inline void OptionMarket::set_allocated_rate(::gooption::RiskFreeRate* rate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rate_;
  }
  if (rate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rate, submessage_arena);
    }
    
  } else {
    
  }
  rate_ = rate;
  // @@protoc_insertion_point(field_set_allocated:gooption.OptionMarket.rate)
}

// -------------------------------------------------------------------

// ImpliedVolQuote

// double timestamp = 1;
inline void ImpliedVolQuote::clear_timestamp() {
  timestamp_ = 0;
}
inline double ImpliedVolQuote::timestamp() const {
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolQuote.timestamp)
  return timestamp_;
}
inline void ImpliedVolQuote::set_timestamp(double value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:gooption.ImpliedVolQuote.timestamp)
}

// .gooption.OptionQuote input = 2;
inline bool ImpliedVolQuote::has_input() const {
  return this != internal_default_instance() && input_ != NULL;
}
inline void ImpliedVolQuote::clear_input() {
  if (GetArenaNoVirtual() == NULL && input_ != NULL) {
    delete input_;
  }
  input_ = NULL;
}
inline const ::gooption::OptionQuote& ImpliedVolQuote::_internal_input() const {
  return *input_;
}
inline const ::gooption::OptionQuote& ImpliedVolQuote::input() const {
  const ::gooption::OptionQuote* p = input_;
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolQuote.input)
  return p != NULL ? *p : *reinterpret_cast<const ::gooption::OptionQuote*>(
      &::gooption::_OptionQuote_default_instance_);
}
inline ::gooption::OptionQuote* ImpliedVolQuote::release_input() {
  // @@protoc_insertion_point(field_release:gooption.ImpliedVolQuote.input)
  
  ::gooption::OptionQuote* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::gooption::OptionQuote* ImpliedVolQuote::mutable_input() {
  
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::gooption::OptionQuote>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gooption.ImpliedVolQuote.input)
  return input_;
}
inline void ImpliedVolQuote::set_allocated_input(::gooption::OptionQuote* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:gooption.ImpliedVolQuote.input)
}

// string error = 3;
inline void ImpliedVolQuote::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImpliedVolQuote::error() const {
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolQuote.error)
  return error_.GetNoArena();
}
inline void ImpliedVolQuote::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gooption.ImpliedVolQuote.error)
}
#if LANG_CXX11
inline void ImpliedVolQuote::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gooption.ImpliedVolQuote.error)
}
#endif
inline void ImpliedVolQuote::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gooption.ImpliedVolQuote.error)
}
inline void ImpliedVolQuote::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gooption.ImpliedVolQuote.error)
}
inline ::std::string* ImpliedVolQuote::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:gooption.ImpliedVolQuote.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImpliedVolQuote::release_error() {
  // @@protoc_insertion_point(field_release:gooption.ImpliedVolQuote.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImpliedVolQuote::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:gooption.ImpliedVolQuote.error)
}

// double vol = 4;
inline void ImpliedVolQuote::clear_vol() {
  vol_ = 0;
}
inline double ImpliedVolQuote::vol() const {
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolQuote.vol)
  return vol_;
}
inline void ImpliedVolQuote::set_vol(double value) {
  
  vol_ = value;
  // @@protoc_insertion_point(field_set:gooption.ImpliedVolQuote.vol)
}

// int64 nbiteration = 5;
inline void ImpliedVolQuote::clear_nbiteration() {
  nbiteration_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ImpliedVolQuote::nbiteration() const {
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolQuote.nbiteration)
  return nbiteration_;
}
inline void ImpliedVolQuote::set_nbiteration(::google::protobuf::int64 value) {
  
  nbiteration_ = value;
  // @@protoc_insertion_point(field_set:gooption.ImpliedVolQuote.nbiteration)
}

// -------------------------------------------------------------------

// ImpliedVolSlice

// double timestamp = 1;
inline void ImpliedVolSlice::clear_timestamp() {
  timestamp_ = 0;
}
inline double ImpliedVolSlice::timestamp() const {
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolSlice.timestamp)
  return timestamp_;
}
inline void ImpliedVolSlice::set_timestamp(double value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:gooption.ImpliedVolSlice.timestamp)
}

// bool iserror = 2;
inline void ImpliedVolSlice::clear_iserror() {
  iserror_ = false;
}
inline bool ImpliedVolSlice::iserror() const {
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolSlice.iserror)
  return iserror_;
}
inline void ImpliedVolSlice::set_iserror(bool value) {
  
  iserror_ = value;
  // @@protoc_insertion_point(field_set:gooption.ImpliedVolSlice.iserror)
}

// double expiry = 3;
inline void ImpliedVolSlice::clear_expiry() {
  expiry_ = 0;
}
inline double ImpliedVolSlice::expiry() const {
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolSlice.expiry)
  return expiry_;
}
inline void ImpliedVolSlice::set_expiry(double value) {
  
  expiry_ = value;
  // @@protoc_insertion_point(field_set:gooption.ImpliedVolSlice.expiry)
}

// repeated .gooption.ImpliedVolQuote quotes = 4;
inline int ImpliedVolSlice::quotes_size() const {
  return quotes_.size();
}
inline void ImpliedVolSlice::clear_quotes() {
  quotes_.Clear();
}
inline ::gooption::ImpliedVolQuote* ImpliedVolSlice::mutable_quotes(int index) {
  // @@protoc_insertion_point(field_mutable:gooption.ImpliedVolSlice.quotes)
  return quotes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::gooption::ImpliedVolQuote >*
ImpliedVolSlice::mutable_quotes() {
  // @@protoc_insertion_point(field_mutable_list:gooption.ImpliedVolSlice.quotes)
  return &quotes_;
}
inline const ::gooption::ImpliedVolQuote& ImpliedVolSlice::quotes(int index) const {
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolSlice.quotes)
  return quotes_.Get(index);
}
inline ::gooption::ImpliedVolQuote* ImpliedVolSlice::add_quotes() {
  // @@protoc_insertion_point(field_add:gooption.ImpliedVolSlice.quotes)
  return quotes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gooption::ImpliedVolQuote >&
ImpliedVolSlice::quotes() const {
  // @@protoc_insertion_point(field_list:gooption.ImpliedVolSlice.quotes)
  return quotes_;
}

// -------------------------------------------------------------------

// ImpliedVolSurface

// double timestamp = 1;
inline void ImpliedVolSurface::clear_timestamp() {
  timestamp_ = 0;
}
inline double ImpliedVolSurface::timestamp() const {
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolSurface.timestamp)
  return timestamp_;
}
inline void ImpliedVolSurface::set_timestamp(double value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:gooption.ImpliedVolSurface.timestamp)
}

// repeated .gooption.ImpliedVolSlice slices = 2;
inline int ImpliedVolSurface::slices_size() const {
  return slices_.size();
}
inline void ImpliedVolSurface::clear_slices() {
  slices_.Clear();
}
inline ::gooption::ImpliedVolSlice* ImpliedVolSurface::mutable_slices(int index) {
  // @@protoc_insertion_point(field_mutable:gooption.ImpliedVolSurface.slices)
  return slices_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::gooption::ImpliedVolSlice >*
ImpliedVolSurface::mutable_slices() {
  // @@protoc_insertion_point(field_mutable_list:gooption.ImpliedVolSurface.slices)
  return &slices_;
}
inline const ::gooption::ImpliedVolSlice& ImpliedVolSurface::slices(int index) const {
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolSurface.slices)
  return slices_.Get(index);
}
inline ::gooption::ImpliedVolSlice* ImpliedVolSurface::add_slices() {
  // @@protoc_insertion_point(field_add:gooption.ImpliedVolSurface.slices)
  return slices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gooption::ImpliedVolSlice >&
ImpliedVolSurface::slices() const {
  // @@protoc_insertion_point(field_list:gooption.ImpliedVolSurface.slices)
  return slices_;
}

// -------------------------------------------------------------------

// PriceRequest

// double pricingdate = 1;
inline void PriceRequest::clear_pricingdate() {
  pricingdate_ = 0;
}
inline double PriceRequest::pricingdate() const {
  // @@protoc_insertion_point(field_get:gooption.PriceRequest.pricingdate)
  return pricingdate_;
}
inline void PriceRequest::set_pricingdate(double value) {
  
  pricingdate_ = value;
  // @@protoc_insertion_point(field_set:gooption.PriceRequest.pricingdate)
}

// .gooption.European contract = 2;
inline bool PriceRequest::has_contract() const {
  return this != internal_default_instance() && contract_ != NULL;
}
inline void PriceRequest::clear_contract() {
  if (GetArenaNoVirtual() == NULL && contract_ != NULL) {
    delete contract_;
  }
  contract_ = NULL;
}
inline const ::gooption::European& PriceRequest::_internal_contract() const {
  return *contract_;
}
inline const ::gooption::European& PriceRequest::contract() const {
  const ::gooption::European* p = contract_;
  // @@protoc_insertion_point(field_get:gooption.PriceRequest.contract)
  return p != NULL ? *p : *reinterpret_cast<const ::gooption::European*>(
      &::gooption::_European_default_instance_);
}
inline ::gooption::European* PriceRequest::release_contract() {
  // @@protoc_insertion_point(field_release:gooption.PriceRequest.contract)
  
  ::gooption::European* temp = contract_;
  contract_ = NULL;
  return temp;
}
inline ::gooption::European* PriceRequest::mutable_contract() {
  
  if (contract_ == NULL) {
    auto* p = CreateMaybeMessage<::gooption::European>(GetArenaNoVirtual());
    contract_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gooption.PriceRequest.contract)
  return contract_;
}
inline void PriceRequest::set_allocated_contract(::gooption::European* contract) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete contract_;
  }
  if (contract) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      contract = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, contract, submessage_arena);
    }
    
  } else {
    
  }
  contract_ = contract;
  // @@protoc_insertion_point(field_set_allocated:gooption.PriceRequest.contract)
}

// .gooption.OptionMarket marketdata = 3;
inline bool PriceRequest::has_marketdata() const {
  return this != internal_default_instance() && marketdata_ != NULL;
}
inline void PriceRequest::clear_marketdata() {
  if (GetArenaNoVirtual() == NULL && marketdata_ != NULL) {
    delete marketdata_;
  }
  marketdata_ = NULL;
}
inline const ::gooption::OptionMarket& PriceRequest::_internal_marketdata() const {
  return *marketdata_;
}
inline const ::gooption::OptionMarket& PriceRequest::marketdata() const {
  const ::gooption::OptionMarket* p = marketdata_;
  // @@protoc_insertion_point(field_get:gooption.PriceRequest.marketdata)
  return p != NULL ? *p : *reinterpret_cast<const ::gooption::OptionMarket*>(
      &::gooption::_OptionMarket_default_instance_);
}
inline ::gooption::OptionMarket* PriceRequest::release_marketdata() {
  // @@protoc_insertion_point(field_release:gooption.PriceRequest.marketdata)
  
  ::gooption::OptionMarket* temp = marketdata_;
  marketdata_ = NULL;
  return temp;
}
inline ::gooption::OptionMarket* PriceRequest::mutable_marketdata() {
  
  if (marketdata_ == NULL) {
    auto* p = CreateMaybeMessage<::gooption::OptionMarket>(GetArenaNoVirtual());
    marketdata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gooption.PriceRequest.marketdata)
  return marketdata_;
}
inline void PriceRequest::set_allocated_marketdata(::gooption::OptionMarket* marketdata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete marketdata_;
  }
  if (marketdata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      marketdata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, marketdata, submessage_arena);
    }
    
  } else {
    
  }
  marketdata_ = marketdata;
  // @@protoc_insertion_point(field_set_allocated:gooption.PriceRequest.marketdata)
}

// -------------------------------------------------------------------

// PriceResponse

// double price = 2;
inline void PriceResponse::clear_price() {
  price_ = 0;
}
inline double PriceResponse::price() const {
  // @@protoc_insertion_point(field_get:gooption.PriceResponse.price)
  return price_;
}
inline void PriceResponse::set_price(double value) {
  
  price_ = value;
  // @@protoc_insertion_point(field_set:gooption.PriceResponse.price)
}

// string error = 3;
inline void PriceResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PriceResponse::error() const {
  // @@protoc_insertion_point(field_get:gooption.PriceResponse.error)
  return error_.GetNoArena();
}
inline void PriceResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gooption.PriceResponse.error)
}
#if LANG_CXX11
inline void PriceResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gooption.PriceResponse.error)
}
#endif
inline void PriceResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gooption.PriceResponse.error)
}
inline void PriceResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gooption.PriceResponse.error)
}
inline ::std::string* PriceResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:gooption.PriceResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PriceResponse::release_error() {
  // @@protoc_insertion_point(field_release:gooption.PriceResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PriceResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:gooption.PriceResponse.error)
}

// -------------------------------------------------------------------

// GreekRequest

// .gooption.PriceRequest request = 1;
inline bool GreekRequest::has_request() const {
  return this != internal_default_instance() && request_ != NULL;
}
inline void GreekRequest::clear_request() {
  if (GetArenaNoVirtual() == NULL && request_ != NULL) {
    delete request_;
  }
  request_ = NULL;
}
inline const ::gooption::PriceRequest& GreekRequest::_internal_request() const {
  return *request_;
}
inline const ::gooption::PriceRequest& GreekRequest::request() const {
  const ::gooption::PriceRequest* p = request_;
  // @@protoc_insertion_point(field_get:gooption.GreekRequest.request)
  return p != NULL ? *p : *reinterpret_cast<const ::gooption::PriceRequest*>(
      &::gooption::_PriceRequest_default_instance_);
}
inline ::gooption::PriceRequest* GreekRequest::release_request() {
  // @@protoc_insertion_point(field_release:gooption.GreekRequest.request)
  
  ::gooption::PriceRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline ::gooption::PriceRequest* GreekRequest::mutable_request() {
  
  if (request_ == NULL) {
    auto* p = CreateMaybeMessage<::gooption::PriceRequest>(GetArenaNoVirtual());
    request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gooption.GreekRequest.request)
  return request_;
}
inline void GreekRequest::set_allocated_request(::gooption::PriceRequest* request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete request_;
  }
  if (request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:gooption.GreekRequest.request)
}

// repeated string greek = 2;
inline int GreekRequest::greek_size() const {
  return greek_.size();
}
inline void GreekRequest::clear_greek() {
  greek_.Clear();
}
inline const ::std::string& GreekRequest::greek(int index) const {
  // @@protoc_insertion_point(field_get:gooption.GreekRequest.greek)
  return greek_.Get(index);
}
inline ::std::string* GreekRequest::mutable_greek(int index) {
  // @@protoc_insertion_point(field_mutable:gooption.GreekRequest.greek)
  return greek_.Mutable(index);
}
inline void GreekRequest::set_greek(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:gooption.GreekRequest.greek)
  greek_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GreekRequest::set_greek(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:gooption.GreekRequest.greek)
  greek_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GreekRequest::set_greek(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  greek_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:gooption.GreekRequest.greek)
}
inline void GreekRequest::set_greek(int index, const char* value, size_t size) {
  greek_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gooption.GreekRequest.greek)
}
inline ::std::string* GreekRequest::add_greek() {
  // @@protoc_insertion_point(field_add_mutable:gooption.GreekRequest.greek)
  return greek_.Add();
}
inline void GreekRequest::add_greek(const ::std::string& value) {
  greek_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:gooption.GreekRequest.greek)
}
#if LANG_CXX11
inline void GreekRequest::add_greek(::std::string&& value) {
  greek_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:gooption.GreekRequest.greek)
}
#endif
inline void GreekRequest::add_greek(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  greek_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:gooption.GreekRequest.greek)
}
inline void GreekRequest::add_greek(const char* value, size_t size) {
  greek_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:gooption.GreekRequest.greek)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GreekRequest::greek() const {
  // @@protoc_insertion_point(field_list:gooption.GreekRequest.greek)
  return greek_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GreekRequest::mutable_greek() {
  // @@protoc_insertion_point(field_mutable_list:gooption.GreekRequest.greek)
  return &greek_;
}

// -------------------------------------------------------------------

// GreekResponse_Greek

// string label = 1;
inline void GreekResponse_Greek::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GreekResponse_Greek::label() const {
  // @@protoc_insertion_point(field_get:gooption.GreekResponse.Greek.label)
  return label_.GetNoArena();
}
inline void GreekResponse_Greek::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gooption.GreekResponse.Greek.label)
}
#if LANG_CXX11
inline void GreekResponse_Greek::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gooption.GreekResponse.Greek.label)
}
#endif
inline void GreekResponse_Greek::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gooption.GreekResponse.Greek.label)
}
inline void GreekResponse_Greek::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gooption.GreekResponse.Greek.label)
}
inline ::std::string* GreekResponse_Greek::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:gooption.GreekResponse.Greek.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GreekResponse_Greek::release_label() {
  // @@protoc_insertion_point(field_release:gooption.GreekResponse.Greek.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GreekResponse_Greek::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:gooption.GreekResponse.Greek.label)
}

// double value = 2;
inline void GreekResponse_Greek::clear_value() {
  value_ = 0;
}
inline double GreekResponse_Greek::value() const {
  // @@protoc_insertion_point(field_get:gooption.GreekResponse.Greek.value)
  return value_;
}
inline void GreekResponse_Greek::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:gooption.GreekResponse.Greek.value)
}

// string error = 3;
inline void GreekResponse_Greek::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GreekResponse_Greek::error() const {
  // @@protoc_insertion_point(field_get:gooption.GreekResponse.Greek.error)
  return error_.GetNoArena();
}
inline void GreekResponse_Greek::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gooption.GreekResponse.Greek.error)
}
#if LANG_CXX11
inline void GreekResponse_Greek::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gooption.GreekResponse.Greek.error)
}
#endif
inline void GreekResponse_Greek::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gooption.GreekResponse.Greek.error)
}
inline void GreekResponse_Greek::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gooption.GreekResponse.Greek.error)
}
inline ::std::string* GreekResponse_Greek::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:gooption.GreekResponse.Greek.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GreekResponse_Greek::release_error() {
  // @@protoc_insertion_point(field_release:gooption.GreekResponse.Greek.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GreekResponse_Greek::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:gooption.GreekResponse.Greek.error)
}

// -------------------------------------------------------------------

// GreekResponse

// repeated .gooption.GreekResponse.Greek greeks = 1;
inline int GreekResponse::greeks_size() const {
  return greeks_.size();
}
inline void GreekResponse::clear_greeks() {
  greeks_.Clear();
}
inline ::gooption::GreekResponse_Greek* GreekResponse::mutable_greeks(int index) {
  // @@protoc_insertion_point(field_mutable:gooption.GreekResponse.greeks)
  return greeks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::gooption::GreekResponse_Greek >*
GreekResponse::mutable_greeks() {
  // @@protoc_insertion_point(field_mutable_list:gooption.GreekResponse.greeks)
  return &greeks_;
}
inline const ::gooption::GreekResponse_Greek& GreekResponse::greeks(int index) const {
  // @@protoc_insertion_point(field_get:gooption.GreekResponse.greeks)
  return greeks_.Get(index);
}
inline ::gooption::GreekResponse_Greek* GreekResponse::add_greeks() {
  // @@protoc_insertion_point(field_add:gooption.GreekResponse.greeks)
  return greeks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gooption::GreekResponse_Greek >&
GreekResponse::greeks() const {
  // @@protoc_insertion_point(field_list:gooption.GreekResponse.greeks)
  return greeks_;
}

// string error = 2;
inline void GreekResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GreekResponse::error() const {
  // @@protoc_insertion_point(field_get:gooption.GreekResponse.error)
  return error_.GetNoArena();
}
inline void GreekResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gooption.GreekResponse.error)
}
#if LANG_CXX11
inline void GreekResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gooption.GreekResponse.error)
}
#endif
inline void GreekResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gooption.GreekResponse.error)
}
inline void GreekResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gooption.GreekResponse.error)
}
inline ::std::string* GreekResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:gooption.GreekResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GreekResponse::release_error() {
  // @@protoc_insertion_point(field_release:gooption.GreekResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GreekResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:gooption.GreekResponse.error)
}

// -------------------------------------------------------------------

// ImpliedVolRequest

// double pricingdate = 1;
inline void ImpliedVolRequest::clear_pricingdate() {
  pricingdate_ = 0;
}
inline double ImpliedVolRequest::pricingdate() const {
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolRequest.pricingdate)
  return pricingdate_;
}
inline void ImpliedVolRequest::set_pricingdate(double value) {
  
  pricingdate_ = value;
  // @@protoc_insertion_point(field_set:gooption.ImpliedVolRequest.pricingdate)
}

// .gooption.OptionMarket marketdata = 2;
inline bool ImpliedVolRequest::has_marketdata() const {
  return this != internal_default_instance() && marketdata_ != NULL;
}
inline void ImpliedVolRequest::clear_marketdata() {
  if (GetArenaNoVirtual() == NULL && marketdata_ != NULL) {
    delete marketdata_;
  }
  marketdata_ = NULL;
}
inline const ::gooption::OptionMarket& ImpliedVolRequest::_internal_marketdata() const {
  return *marketdata_;
}
inline const ::gooption::OptionMarket& ImpliedVolRequest::marketdata() const {
  const ::gooption::OptionMarket* p = marketdata_;
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolRequest.marketdata)
  return p != NULL ? *p : *reinterpret_cast<const ::gooption::OptionMarket*>(
      &::gooption::_OptionMarket_default_instance_);
}
inline ::gooption::OptionMarket* ImpliedVolRequest::release_marketdata() {
  // @@protoc_insertion_point(field_release:gooption.ImpliedVolRequest.marketdata)
  
  ::gooption::OptionMarket* temp = marketdata_;
  marketdata_ = NULL;
  return temp;
}
inline ::gooption::OptionMarket* ImpliedVolRequest::mutable_marketdata() {
  
  if (marketdata_ == NULL) {
    auto* p = CreateMaybeMessage<::gooption::OptionMarket>(GetArenaNoVirtual());
    marketdata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gooption.ImpliedVolRequest.marketdata)
  return marketdata_;
}
inline void ImpliedVolRequest::set_allocated_marketdata(::gooption::OptionMarket* marketdata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete marketdata_;
  }
  if (marketdata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      marketdata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, marketdata, submessage_arena);
    }
    
  } else {
    
  }
  marketdata_ = marketdata;
  // @@protoc_insertion_point(field_set_allocated:gooption.ImpliedVolRequest.marketdata)
}

// repeated .gooption.OptionQuoteSlice quotes = 3;
inline int ImpliedVolRequest::quotes_size() const {
  return quotes_.size();
}
inline void ImpliedVolRequest::clear_quotes() {
  quotes_.Clear();
}
inline ::gooption::OptionQuoteSlice* ImpliedVolRequest::mutable_quotes(int index) {
  // @@protoc_insertion_point(field_mutable:gooption.ImpliedVolRequest.quotes)
  return quotes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuoteSlice >*
ImpliedVolRequest::mutable_quotes() {
  // @@protoc_insertion_point(field_mutable_list:gooption.ImpliedVolRequest.quotes)
  return &quotes_;
}
inline const ::gooption::OptionQuoteSlice& ImpliedVolRequest::quotes(int index) const {
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolRequest.quotes)
  return quotes_.Get(index);
}
inline ::gooption::OptionQuoteSlice* ImpliedVolRequest::add_quotes() {
  // @@protoc_insertion_point(field_add:gooption.ImpliedVolRequest.quotes)
  return quotes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gooption::OptionQuoteSlice >&
ImpliedVolRequest::quotes() const {
  // @@protoc_insertion_point(field_list:gooption.ImpliedVolRequest.quotes)
  return quotes_;
}

// -------------------------------------------------------------------

// ImpliedVolResponse

// .gooption.ImpliedVolSurface volsurface = 1;
inline bool ImpliedVolResponse::has_volsurface() const {
  return this != internal_default_instance() && volsurface_ != NULL;
}
inline void ImpliedVolResponse::clear_volsurface() {
  if (GetArenaNoVirtual() == NULL && volsurface_ != NULL) {
    delete volsurface_;
  }
  volsurface_ = NULL;
}
inline const ::gooption::ImpliedVolSurface& ImpliedVolResponse::_internal_volsurface() const {
  return *volsurface_;
}
inline const ::gooption::ImpliedVolSurface& ImpliedVolResponse::volsurface() const {
  const ::gooption::ImpliedVolSurface* p = volsurface_;
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolResponse.volsurface)
  return p != NULL ? *p : *reinterpret_cast<const ::gooption::ImpliedVolSurface*>(
      &::gooption::_ImpliedVolSurface_default_instance_);
}
inline ::gooption::ImpliedVolSurface* ImpliedVolResponse::release_volsurface() {
  // @@protoc_insertion_point(field_release:gooption.ImpliedVolResponse.volsurface)
  
  ::gooption::ImpliedVolSurface* temp = volsurface_;
  volsurface_ = NULL;
  return temp;
}
inline ::gooption::ImpliedVolSurface* ImpliedVolResponse::mutable_volsurface() {
  
  if (volsurface_ == NULL) {
    auto* p = CreateMaybeMessage<::gooption::ImpliedVolSurface>(GetArenaNoVirtual());
    volsurface_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gooption.ImpliedVolResponse.volsurface)
  return volsurface_;
}
inline void ImpliedVolResponse::set_allocated_volsurface(::gooption::ImpliedVolSurface* volsurface) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete volsurface_;
  }
  if (volsurface) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      volsurface = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, volsurface, submessage_arena);
    }
    
  } else {
    
  }
  volsurface_ = volsurface;
  // @@protoc_insertion_point(field_set_allocated:gooption.ImpliedVolResponse.volsurface)
}

// string error = 2;
inline void ImpliedVolResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImpliedVolResponse::error() const {
  // @@protoc_insertion_point(field_get:gooption.ImpliedVolResponse.error)
  return error_.GetNoArena();
}
inline void ImpliedVolResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gooption.ImpliedVolResponse.error)
}
#if LANG_CXX11
inline void ImpliedVolResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gooption.ImpliedVolResponse.error)
}
#endif
inline void ImpliedVolResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gooption.ImpliedVolResponse.error)
}
inline void ImpliedVolResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gooption.ImpliedVolResponse.error)
}
inline ::std::string* ImpliedVolResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:gooption.ImpliedVolResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImpliedVolResponse::release_error() {
  // @@protoc_insertion_point(field_release:gooption.ImpliedVolResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImpliedVolResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:gooption.ImpliedVolResponse.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gooption

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_service_2eproto
